(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{328:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(86)),__export(__webpack_require__(763));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{NumberScheduler.displayName="NumberScheduler",NumberScheduler.__docgenInfo={description:"A `NumberScheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"NumberScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#NumberScheduler"]={docgenInfo:NumberScheduler.__docgenInfo,name:"NumberScheduler",path:"src/index.ts#NumberScheduler"})}catch(__react_docgen_typescript_loader_error){}try{BooleanScheduler.displayName="BooleanScheduler",BooleanScheduler.__docgenInfo={description:"A `BooleanScheduler` returns some boolean value that changes over time according to a sequence of\nactive ranges.",displayName:"BooleanScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BooleanScheduler"]={docgenInfo:BooleanScheduler.__docgenInfo,name:"BooleanScheduler",path:"src/index.ts#BooleanScheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{ScheduledOptimizer.displayName="ScheduledOptimizer",ScheduledOptimizer.__docgenInfo={description:"A `ScheduledOptimizer` uses a variable learning rate set by a `Scheduler`.",displayName:"ScheduledOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#ScheduledOptimizer"]={docgenInfo:ScheduledOptimizer.__docgenInfo,name:"ScheduledOptimizer",path:"src/index.ts#ScheduledOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{EnergyOptimizer.displayName="EnergyOptimizer",EnergyOptimizer.__docgenInfo={description:"A `EnergyOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before). The energy function\nis the squared norm of all the gradients between successive `update()` calls.",displayName:"EnergyOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#EnergyOptimizer"]={docgenInfo:EnergyOptimizer.__docgenInfo,name:"EnergyOptimizer",path:"src/index.ts#EnergyOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{RMSPropOptimizer.displayName="RMSPropOptimizer",RMSPropOptimizer.__docgenInfo={description:"A `RMSPropOptimizer` uses an adaptive scheme based on a per-parameter moving weighted average of\nmagnitudes.",displayName:"RMSPropOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#RMSPropOptimizer"]={docgenInfo:RMSPropOptimizer.__docgenInfo,name:"RMSPropOptimizer",path:"src/index.ts#RMSPropOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme that increasing the learning rate if the\ngradients are growing, and decreasing the learning rate if the gradients are shrinking.",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas\n@param config `shapeCreator`: Function converting `ShapeSchema` to `Shape`.\n`portLocation`: Location to assign to port if unspecified. (default: 'center')",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or 2-array of gradients in order `[p, q]`.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`.\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or tuple of gradients in order `[p, q]`.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{nudgeAngle.displayName="nudgeAngle",nudgeAngle.__docgenInfo={description:"Nudges the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. The angle is measured counterclockwise from 0 (as\nin trigonometry) but since browser's render the positive-y direction pointing downwards, the\nresult may appear opposite than intended if unaccounted for.\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle Single angle or array of angles, in degrees within range [0, 360].\n@param strength Maximum restoring force (felt when points directly opposite the desired angle).\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgeAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#nudgeAngle"]={docgenInfo:nudgeAngle.__docgenInfo,name:"nudgeAngle",path:"src/index.ts#nudgeAngle"})}catch(__react_docgen_typescript_loader_error){}try{nudgePair.displayName="nudgePair",nudgePair.__docgenInfo={description:"Nudges the pair of points in opposite directions, away from each other if `magnitude` is\npositive, and towards each other if the `magnitude` is negative. It is possible to specify\ndifferent `magnitude` for each point.\n@param p Point vector.\n@param q Point vector.\n@param magnitude Single magnitude or tuple of magnitudes. Nudges away from each other if positive, and\nnudges towards each other if negative.\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgePair",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#nudgePair"]={docgenInfo:nudgePair.__docgenInfo,name:"nudgePair",path:"src/index.ts#nudgePair"})}catch(__react_docgen_typescript_loader_error){}try{nudgePoint.displayName="nudgePoint",nudgePoint.__docgenInfo={description:"Nudges a point (or array of points) in the specified `direction` with `magnitude`.\n@param points Point vector or array of point vectors.\n@param magnitude Magnitude scalar.\n@param direction Direction vector, unnormalized.\n@returns     Array of gradients for each point.",displayName:"nudgePoint",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#nudgePoint"]={docgenInfo:nudgePoint.__docgenInfo,name:"nudgePoint",path:"src/index.ts#nudgePoint"})}catch(__react_docgen_typescript_loader_error){}try{generateNodePortConstraints.displayName="generateNodePortConstraints",generateNodePortConstraints.__docgenInfo={description:"Constrains `u`'s ports (if any) to be at their correct `location` on the node's boundary,\nin their correct `order` relative to other ports, if specified. If no port is specified\n@param u Node with ports to constrain.\n@param centering Strength of port attraction towards center of each side. (default: 0.1)\n@param gap Minimum distance between successive ports at a location. (default: 8)",displayName:"generateNodePortConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateNodePortConstraints"]={docgenInfo:generateNodePortConstraints.__docgenInfo,name:"generateNodePortConstraints",path:"src/index.ts#generateNodePortConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeNonoverlap.displayName="constrainNodeNonoverlap",constrainNodeNonoverlap.__docgenInfo={description:"@param u First node of pair to ensure nonoverlap.\n@param v Second node of pair to ensure nonoverlap.\n@param margin Spacing outside each node's boundary.",displayName:"constrainNodeNonoverlap",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainNodeNonoverlap"]={docgenInfo:constrainNodeNonoverlap.__docgenInfo,name:"constrainNodeNonoverlap",path:"src/index.ts#constrainNodeNonoverlap"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeAlignmentConstraints.displayName="generateNodeAlignmentConstraints",generateNodeAlignmentConstraints.__docgenInfo={description:"@param nodes\n@param axis",displayName:"generateNodeAlignmentConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateNodeAlignmentConstraints"]={docgenInfo:generateNodeAlignmentConstraints.__docgenInfo,name:"generateNodeAlignmentConstraints",path:"src/index.ts#generateNodeAlignmentConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeDistance.displayName="constrainNodeDistance",constrainNodeDistance.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainNodeDistance"]={docgenInfo:constrainNodeDistance.__docgenInfo,name:"constrainNodeDistance",path:"src/index.ts#constrainNodeDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeOffset.displayName="constrainNodeOffset",constrainNodeOffset.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainNodeOffset"]={docgenInfo:constrainNodeOffset.__docgenInfo,name:"constrainNodeOffset",path:"src/index.ts#constrainNodeOffset"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeCircular.displayName="constrainNodeCircular",constrainNodeCircular.__docgenInfo={description:"@param u\n@param v",displayName:"constrainNodeCircular",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainNodeCircular"]={docgenInfo:constrainNodeCircular.__docgenInfo,name:"constrainNodeCircular",path:"src/index.ts#constrainNodeCircular"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeGrid.displayName="constrainNodeGrid",constrainNodeGrid.__docgenInfo={description:"@param u\n@param dx\n@param dy",displayName:"constrainNodeGrid",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainNodeGrid"]={docgenInfo:constrainNodeGrid.__docgenInfo,name:"constrainNodeGrid",path:"src/index.ts#constrainNodeGrid"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/index.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{StagedLayout.displayName="StagedLayout",StagedLayout.__docgenInfo={description:"A `StagedLayout` performs a fixed number of optimization steps, where each step involved\nexecuting all stages of a computation. A single stage uses a generator function to generate\ngradients, which optimizer applies. Each stage may be repeated for a different fixed number\nof iterations.",displayName:"StagedLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#StagedLayout"]={docgenInfo:StagedLayout.__docgenInfo,name:"StagedLayout",path:"src/index.ts#StagedLayout"})}catch(__react_docgen_typescript_loader_error){}try{generateSpringForces.displayName="generateSpringForces",generateSpringForces.__docgenInfo={description:"Generates (1) attractive forces encouraging connected nodes to be no farther than their ideal\ndistance, and (2) repulsive forces between unconnected nodes encouraging them to be no closer\nthan their ideal distance. The ideal distance is the shortest path length scaled by the ideal\nlength. There are no forces generated between nodes of different connected components (with\nundefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a non-undefined `shortestPath`.\n@param shortestPath",displayName:"generateSpringForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateSpringForces"]={docgenInfo:generateSpringForces.__docgenInfo,name:"generateSpringForces",path:"src/index.ts#generateSpringForces"})}catch(__react_docgen_typescript_loader_error){}try{generateSpringElectricalForces.displayName="generateSpringElectricalForces",generateSpringElectricalForces.__docgenInfo={description:"Generates attractive forces encouraging edges to be no fthe ideal length and repulsive forces between\nunconnected nodes proportional to their shortest path length. There are no forces generated\nbetween forces from different connected components (with undefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a direct edge.\n@param shortestPath",displayName:"generateSpringElectricalForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateSpringElectricalForces"]={docgenInfo:generateSpringElectricalForces.__docgenInfo,name:"generateSpringElectricalForces",path:"src/index.ts#generateSpringElectricalForces"})}catch(__react_docgen_typescript_loader_error){}try{generateCompactnessForces.displayName="generateCompactnessForces",generateCompactnessForces.__docgenInfo={description:"Generates forces that pull children nodes towards the parent's center.\n@param storage\n@param strength",displayName:"generateCompactnessForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateCompactnessForces"]={docgenInfo:generateCompactnessForces.__docgenInfo,name:"generateCompactnessForces",path:"src/index.ts#generateCompactnessForces"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeChildrenConstraints.displayName="generateNodeChildrenConstraints",generateNodeChildrenConstraints.__docgenInfo={description:"Constrain `u`'s children to be contained within itself, expansing its boundaries if necessary.\n@param u Node with children to constrain.\n@param padding Spacing inside the node's boundary.",displayName:"generateNodeChildrenConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#generateNodeChildrenConstraints"]={docgenInfo:generateNodeChildrenConstraints.__docgenInfo,name:"generateNodeChildrenConstraints",path:"src/index.ts#generateNodeChildrenConstraints"})}catch(__react_docgen_typescript_loader_error){}},329:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(206),optim_1=__webpack_require__(86),kZeroThreshold=.001;function constrainDistance(p,q,op,distance,{axis:axis,masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=axis?new optim_1.Vector(axis[0],axis[1]).normalize():pq.clone().normalize(),current=axis?Math.abs(pq.dot(v)):pq.length();if(">="===op&&current>=distance+kZeroThreshold)return[];if("<="===op&&current<=distance-kZeroThreshold)return[];if("="===op&&Math.abs(current-distance)<=kZeroThreshold)return[];const delta=distance-current;masses||(masses=[1,1]),pq.dot(v)<0&&v.negate();const gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1]));return[new optim_1.Gradient(p,gradp),new optim_1.Gradient(q,gradq)]}function constrainOffset(p,q,op,offset,direction,{masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=new optim_1.Vector(direction[0],direction[1]).normalize(),projected=pq.dot(v);if(">="===op&&projected>=offset+kZeroThreshold)return[];if("<="===op&&projected<=offset-kZeroThreshold)return[];if("="===op&&Math.abs(projected-offset)<=kZeroThreshold)return[];const delta=offset-projected,gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1]));return[new optim_1.Gradient(p,gradp),new optim_1.Gradient(q,gradq)]}function nudgeAngle(p,q,angle,strength=1,{masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p).normalize(),pqAngle=180*Math.atan2(pq.y,pq.x)/Math.PI;let desired;if(Array.isArray(angle)){if(0===angle.length)throw Error("No angles specified");desired=angle[0];let mindiff=Number.POSITIVE_INFINITY;for(let a of angle){const diff=180-Math.abs(Math.abs(a-pqAngle)-180);diff<mindiff&&(desired=a,mindiff=diff)}}else desired=angle;const delta=strength*((pqAngle-desired-540)%360+180)/180,gradq=new optim_1.Vector(pq.y,-pq.x).multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=new optim_1.Vector(-pq.y,pq.x).multiplyScalar(delta*masses[1]/(masses[0]+masses[1]));return[new optim_1.Gradient(p,gradp),new optim_1.Gradient(q,gradq)]}function nudgePair(p,q,magnitude){Array.isArray(magnitude)||(magnitude=[magnitude,magnitude]);const qp=(new optim_1.Vector).subVectors(p,q).normalize(),pq=qp.clone().negate();return qp.multiplyScalar(magnitude[0]),pq.multiplyScalar(magnitude[1]),[new optim_1.Gradient(p,qp),new optim_1.Gradient(q,pq)]}function nudgePoint(points,magnitude,direction){Array.isArray(points)||(points=[points]);const grad=new optim_1.Vector(direction[0],direction[1]).normalize().multiplyScalar(magnitude);return points.map(p=>new optim_1.Gradient(p,grad.clone()))}exports.constrainDistance=constrainDistance,exports.constrainOffset=constrainOffset,exports.nudgeAngle=nudgeAngle,exports.nudgePair=nudgePair,exports.nudgePoint=nudgePoint;const kPortMasses=[1e6,1];function*generateNodePortConstraints(u,centering=.5,gap=8){const ports=Object.values(u.ports),orders={north:[],south:[],east:[],west:[],boundary:[],center:[]};ports.forEach(port=>{void 0!==port.order&&orders[port.location].push(port)});const{x:cx,y:cy}=u.center,{width:width,height:height,x:x,y:y,X:X,Y:Y}=u.shape.bounds();for(let{location:location,order:order,point:point}of ports){if("center"===location){yield constrainDistance(u.center,point,"=",0,{masses:kPortMasses});continue}let side;if("boundary"===location){const ray=(new optim_1.Vector).subVectors(point,u.center),risingNormalDot=ray.x*-height+ray.y*-width,fallingNormalDot=ray.x*height+ray.y*-width;side=risingNormalDot>0?fallingNormalDot>0?"north":"west":fallingNormalDot>0?"east":"south"}else side=location;switch(yield u.shape.constrainPointOnBoundary(point,{masses:{shape:1e3,point:1},offset:0}),side){case"north":yield nudgePair(new optim_1.Vector(cx,.99*y),point,[0,-centering]),yield constrainOffset(u.center,point,"=",-height/2,[0,1],{masses:kPortMasses});break;case"south":yield nudgePair(new optim_1.Vector(cx,.99*Y),point,[0,-centering]),yield constrainOffset(u.center,point,"=",height/2,[0,1],{masses:kPortMasses});break;case"west":yield nudgePair(new optim_1.Vector(.99*x,cy),point,[0,-centering]),yield constrainOffset(u.center,point,"=",-width/2,[1,0],{masses:kPortMasses});break;case"east":yield nudgePair(new optim_1.Vector(.99*X,cy),point,[0,-centering]),yield constrainOffset(u.center,point,"=",width/2,[1,0],{masses:kPortMasses})}for(let{point:p}of ports.filter(({location:location,point:p})=>"center"!==location&&p!==point))yield constrainDistance(point,p,">=",gap);if("boundary"===location)return;if(void 0!==order)for(let port of orders[location])order<port.order&&(yield constrainOffset(point,port.point,">=",gap,"north"===location||"south"===location?[1,0]:[0,1]))}}function constrainNodeNonoverlap(u,v,margin=0){const{x:ux,y:uy,X:uX,Y:uY,width:uwidth,height:uheight}=u.shape.bounds(),{x:vx,y:vy,X:vX,Y:vY,width:vwidth,height:vheight}=v.shape.bounds(),ubounds=new three_1.Box2(new optim_1.Vector(ux,uy),new optim_1.Vector(uX,uY)),vbounds=new three_1.Box2(new optim_1.Vector(vx,vy),new optim_1.Vector(vX,vY));if(!ubounds.intersectsBox(vbounds))return[];const xgrad=constrainDistance(u.center,v.center,">=",(uwidth+vwidth)/2,{axis:[1,0]}),ygrad=constrainDistance(u.center,v.center,">=",(uheight+vheight)/2,{axis:[0,1]}),shorter=xgrad.reduce((sum,grad)=>sum+grad.grad.length(),0)<ygrad.reduce((sum,grad)=>sum+grad.grad.length(),0)?xgrad:ygrad;function moveChildren(p,grad){p.children.length>0&&p.children.forEach(c=>{shorter.push(new optim_1.Gradient(c.center,grad)),moveChildren(c,grad)})}for(let grad of shorter)grad.point===u.center&&moveChildren(u,grad.grad),grad.point===v.center&&moveChildren(v,grad.grad);return shorter}function*generateNodeAlignmentConstraints(nodes,axis,align="center"){const[x,y]=axis;if(nodes.length<2)return;for(let i=0;i<nodes.length-1;i++){const u=nodes[i],v=nodes[i+1],p=u.center.clone(),q=v.center.clone();switch(align){case"north":p.y+=u.shape.support(new optim_1.Vector(0,-1)).sub(u.center).y,q.y+=v.shape.support(new optim_1.Vector(0,-1)).sub(v.center).y;break;case"south":p.y+=u.shape.support(new optim_1.Vector(0,1)).sub(u.center).y,q.y+=v.shape.support(new optim_1.Vector(0,1)).sub(v.center).y;break;case"east":p.x+=u.shape.support(new optim_1.Vector(0,1)).sub(u.center).x,q.x+=v.shape.support(new optim_1.Vector(0,1)).sub(v.center).x;break;case"west":p.x+=u.shape.support(new optim_1.Vector(0,-1)).sub(u.center).x,q.x+=v.shape.support(new optim_1.Vector(0,-1)).sub(v.center).x}const newGrads=constrainDistance(p,q,"=",0,{axis:[-y,x]});yield newGrads.map(grad=>new optim_1.Gradient(grad.point===p?u.center:v.center,grad.grad))}}function constrainNodeDistance(u,v,op,distance,{axis:axis,masses:masses=[1,1]}={}){const supportAxis=(new optim_1.Vector).subVectors(v.center,u.center),us=u.shape.support(supportAxis),vs=v.shape.support(supportAxis.negate());return constrainDistance(us,vs,op,distance,{axis:axis,masses:masses}).map(grad=>{if(grad.point===us)return new optim_1.Gradient(u.center,grad.grad);if(grad.point===vs)return new optim_1.Gradient(v.center,grad.grad);throw Error("Gradient for unknown point returned by `constrainOffset()`.")})}function constrainNodeOffset(u,v,op,offset,direction,{masses:masses=[1,1]}={}){const axis=new optim_1.Vector(...direction),us=u.shape.support(axis),vs=v.shape.support(axis.negate());return constrainOffset(us,vs,op,offset,direction,{masses:masses}).map(grad=>{if(grad.point===us)return new optim_1.Gradient(u.center,grad.grad);if(grad.point===vs)return new optim_1.Gradient(v.center,grad.grad);throw Error("Gradient for unknown point returned by `constrainOffset()`.")})}function constrainNodeCircular(nodes,radius){return[]}function constrainNodeGrid(u,dx,dy){const snapx=Math.floor(u.center.x/dx)*dx,snapy=Math.floor(u.center.y/dy)*dy;return constrainDistance(u.center,new optim_1.Vector(snapx,snapy),"=",0)}exports.generateNodePortConstraints=generateNodePortConstraints,exports.constrainNodeNonoverlap=constrainNodeNonoverlap,exports.generateNodeAlignmentConstraints=generateNodeAlignmentConstraints,exports.constrainNodeDistance=constrainNodeDistance,exports.constrainNodeOffset=constrainNodeOffset,exports.constrainNodeCircular=constrainNodeCircular,exports.constrainNodeGrid=constrainNodeGrid;try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or 2-array of gradients in order `[p, q]`.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/gradients.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`.\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or tuple of gradients in order `[p, q]`.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/gradients.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{nudgeAngle.displayName="nudgeAngle",nudgeAngle.__docgenInfo={description:"Nudges the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. The angle is measured counterclockwise from 0 (as\nin trigonometry) but since browser's render the positive-y direction pointing downwards, the\nresult may appear opposite than intended if unaccounted for.\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle Single angle or array of angles, in degrees within range [0, 360].\n@param strength Maximum restoring force (felt when points directly opposite the desired angle).\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgeAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#nudgeAngle"]={docgenInfo:nudgeAngle.__docgenInfo,name:"nudgeAngle",path:"src/graph/gradients.ts#nudgeAngle"})}catch(__react_docgen_typescript_loader_error){}try{nudgePair.displayName="nudgePair",nudgePair.__docgenInfo={description:"Nudges the pair of points in opposite directions, away from each other if `magnitude` is\npositive, and towards each other if the `magnitude` is negative. It is possible to specify\ndifferent `magnitude` for each point.\n@param p Point vector.\n@param q Point vector.\n@param magnitude Single magnitude or tuple of magnitudes. Nudges away from each other if positive, and\nnudges towards each other if negative.\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgePair",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#nudgePair"]={docgenInfo:nudgePair.__docgenInfo,name:"nudgePair",path:"src/graph/gradients.ts#nudgePair"})}catch(__react_docgen_typescript_loader_error){}try{nudgePoint.displayName="nudgePoint",nudgePoint.__docgenInfo={description:"Nudges a point (or array of points) in the specified `direction` with `magnitude`.\n@param points Point vector or array of point vectors.\n@param magnitude Magnitude scalar.\n@param direction Direction vector, unnormalized.\n@returns     Array of gradients for each point.",displayName:"nudgePoint",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#nudgePoint"]={docgenInfo:nudgePoint.__docgenInfo,name:"nudgePoint",path:"src/graph/gradients.ts#nudgePoint"})}catch(__react_docgen_typescript_loader_error){}try{generateNodePortConstraints.displayName="generateNodePortConstraints",generateNodePortConstraints.__docgenInfo={description:"Constrains `u`'s ports (if any) to be at their correct `location` on the node's boundary,\nin their correct `order` relative to other ports, if specified. If no port is specified\n@param u Node with ports to constrain.\n@param centering Strength of port attraction towards center of each side. (default: 0.1)\n@param gap Minimum distance between successive ports at a location. (default: 8)",displayName:"generateNodePortConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#generateNodePortConstraints"]={docgenInfo:generateNodePortConstraints.__docgenInfo,name:"generateNodePortConstraints",path:"src/graph/gradients.ts#generateNodePortConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeNonoverlap.displayName="constrainNodeNonoverlap",constrainNodeNonoverlap.__docgenInfo={description:"@param u First node of pair to ensure nonoverlap.\n@param v Second node of pair to ensure nonoverlap.\n@param margin Spacing outside each node's boundary.",displayName:"constrainNodeNonoverlap",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainNodeNonoverlap"]={docgenInfo:constrainNodeNonoverlap.__docgenInfo,name:"constrainNodeNonoverlap",path:"src/graph/gradients.ts#constrainNodeNonoverlap"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeAlignmentConstraints.displayName="generateNodeAlignmentConstraints",generateNodeAlignmentConstraints.__docgenInfo={description:"@param nodes\n@param axis",displayName:"generateNodeAlignmentConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#generateNodeAlignmentConstraints"]={docgenInfo:generateNodeAlignmentConstraints.__docgenInfo,name:"generateNodeAlignmentConstraints",path:"src/graph/gradients.ts#generateNodeAlignmentConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeDistance.displayName="constrainNodeDistance",constrainNodeDistance.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainNodeDistance"]={docgenInfo:constrainNodeDistance.__docgenInfo,name:"constrainNodeDistance",path:"src/graph/gradients.ts#constrainNodeDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeOffset.displayName="constrainNodeOffset",constrainNodeOffset.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainNodeOffset"]={docgenInfo:constrainNodeOffset.__docgenInfo,name:"constrainNodeOffset",path:"src/graph/gradients.ts#constrainNodeOffset"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeCircular.displayName="constrainNodeCircular",constrainNodeCircular.__docgenInfo={description:"@param u\n@param v",displayName:"constrainNodeCircular",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainNodeCircular"]={docgenInfo:constrainNodeCircular.__docgenInfo,name:"constrainNodeCircular",path:"src/graph/gradients.ts#constrainNodeCircular"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeGrid.displayName="constrainNodeGrid",constrainNodeGrid.__docgenInfo={description:"@param u\n@param dx\n@param dy",displayName:"constrainNodeGrid",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainNodeGrid"]={docgenInfo:constrainNodeGrid.__docgenInfo,name:"constrainNodeGrid",path:"src/graph/gradients.ts#constrainNodeGrid"})}catch(__react_docgen_typescript_loader_error){}},330:function(module,exports,__webpack_require__){"use strict";var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)Object.hasOwnProperty.call(mod,k)&&(result[k]=mod[k]);return result.default=mod,result};Object.defineProperty(exports,"__esModule",{value:!0});const React=__importStar(__webpack_require__(0)),optim_1=__webpack_require__(86),kPortRadius=2,kAnimationTick=0,kLayoutSteps=250;class Graph extends React.Component{constructor(props){super(props),this.onMouseDown=(node,x,y)=>{if(!this.props.interactive)return;void 0!==this.state.drag&&this.onMouseUp();const fixed=node.fixed;this.setState(state=>({drag:{node:node,origin:{x:x,y:y},center:{x:node.center.x,y:node.center.y},fixed:fixed,bounds:state.bounds}})),node.fixed=!0,this.doLayout(kLayoutSteps)},this.onMouseUp=()=>{if(this.props.interactive&&void 0!==this.state.drag){const{layout:layout}=this.props,{node:node,fixed:fixed}=this.state.drag;node.fixed=fixed,this.setState({drag:void 0}),this.setState({nodes:layout.storage.nodes(),edges:layout.storage.edges(),bounds:layout.storage.bounds()})}},this.onMouseMove=(x,y)=>{if(this.props.interactive&&void 0!==this.state.drag){const{node:node,origin:origin,center:center}=this.state.drag;node.center.set(x-origin.x+center.x,y-origin.y+center.y),this.forceUpdate()}};const{layout:layout,animated:animated}=this.props;this.state={nodes:layout.storage.nodes(),edges:layout.storage.edges(),bounds:layout.storage.bounds(),drag:void 0},animated?layout.onStep=storage=>(this.setState({nodes:storage.nodes(),edges:storage.edges(),bounds:storage.bounds()}),setTimeout(()=>layout.start(),kAnimationTick),!1):layout.onEnd=storage=>{this.setState({nodes:storage.nodes(),edges:storage.edges(),bounds:storage.bounds()}),layout.onStep=storage=>(this.setState({nodes:storage.nodes(),edges:storage.edges(),bounds:storage.bounds()}),!0)}}componentDidMount(){const{layout:layout}=this.props;setTimeout(()=>layout.start(),0)}doLayout(steps){steps<=0||setTimeout(()=>{this.props.layout.step(),this.forceUpdate(),void 0===this.state.drag?this.doLayout(steps-1):this.doLayout(kLayoutSteps)},kAnimationTick)}render(){const{nodes:nodes=[],edges:edges=[],drag:drag}=this.state,bounds=drag?drag.bounds:this.state.bounds,{size:size=[0,0]}=this.props,nodeColor=n=>{if(!this.props.nodeColor)return Palette[0];const value=this.props.nodeColor(n);return"number"==typeof value?Palette[value%Palette.length]:value},edgeColor=e=>{if(!this.props.edgeColor)return Palette[13];const value=this.props.edgeColor(e);return"number"==typeof value?Palette[value%Palette.length]:value},compoundNodeComponents=[];for(let node of nodes)if(node.children.length>0){const shapeSchema=node.shape.toSchema();let shape;switch(shapeSchema.type){case"rectangle":const{width:width,height:height}=shapeSchema;shape=React.createElement("rect",{x:node.shape.bounds().x,y:node.shape.bounds().y,width:width,height:height,fill:nodeColor(node),stroke:Color.white,strokeWidth:1.5,rx:4,opacity:.3});break;case"circle":const{radius:radius}=shapeSchema;shape=React.createElement("circle",{cx:node.shape.center.x,cy:node.shape.center.y,r:radius,fill:nodeColor(node),stroke:Color.white,strokeWidth:1.5,rx:4,opacity:.3})}compoundNodeComponents.push(React.createElement("g",{key:node.id,id:node.id},shape,React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontWeight:"bold",fontSize:"10",fill:nodeColor(node),opacity:1,pointerEvents:"none",userSelect:"none"}},node.id.substring(1)),Object.entries(node.ports).map(([name,port])=>name.startsWith("_")?null:React.createElement("circle",{cx:port.point.x,cy:port.point.y,r:kPortRadius,fill:nodeColor(node),stroke:Color.white,strokeWidth:.75}))))}const simpleNodeComponents=[];for(let node of nodes)if(0==node.children.length){const shapeSchema=node.shape.toSchema();let shape;switch(shapeSchema.type){case"rectangle":const{width:width,height:height}=shapeSchema;shape=React.createElement("rect",{x:node.shape.bounds().x,y:node.shape.bounds().y,width:width,height:height,fill:nodeColor(node),stroke:Color.white,strokeWidth:1,rx:4,onMouseDown:e=>this.onMouseDown(node,e.clientX,e.clientY)});break;case"circle":const{radius:radius}=shapeSchema;shape=React.createElement("circle",{cx:node.shape.center.x,cy:node.shape.center.y,r:radius,fill:nodeColor(node),stroke:Color.white,strokeWidth:1,onMouseDown:e=>this.onMouseDown(node,e.clientX,e.clientY)})}simpleNodeComponents.push(React.createElement("g",{key:node.id,id:node.id},shape,React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontSize:"10",fill:Color.white,opacity:.75,pointerEvents:"none",userSelect:"none"}},node.id.substring(1)),Object.entries(node.ports).map(([name,port])=>name.startsWith("_")?null:React.createElement("circle",{cx:port.point.x,cy:port.point.y,r:kPortRadius,fill:nodeColor(node),stroke:Color.white,strokeWidth:.75}))))}const edgeComponents=[];for(let edge of edges){const start=edge.path[0],end=edge.path[edge.path.length-1];"center"===edge.source.node.ports[edge.source.port].location&&start.copy(edge.source.node.shape.boundary((new optim_1.Vector).subVectors(end,start))),"center"===edge.target.node.ports[edge.target.port].location&&end.copy(edge.target.node.shape.boundary((new optim_1.Vector).subVectors(start,end))),edgeComponents.push(React.createElement("g",{key:edge.id,id:edge.id},React.createElement("path",{d:"M "+edge.path.map(({x:x,y:y})=>`${x} ${y}`).join(" L "),style:{fill:"none",stroke:edgeColor(edge),strokeWidth:2,opacity:.75}})))}return React.createElement("svg",{viewBox:bounds?`${bounds.x} ${bounds.y} ${Math.max(bounds.width,size[0])} ${Math.max(bounds.height,size[1])}`:void 0,width:bounds?`${Math.max(bounds.width,size[0])}`:"100%",height:bounds?`${Math.max(bounds.height,size[1])}`:"100%",onMouseMove:e=>this.onMouseMove(e.clientX,e.clientY),onMouseUp:e=>this.onMouseUp()},edgeComponents,compoundNodeComponents,simpleNodeComponents)}}exports.Graph=Graph,Graph.defaultProps={animated:!1,interactive:!1,size:[500,500]};const Color={white:"#FFFFFF",black:"#000000",gray:{l2:"#F1F3F5",l1:"#E9ECEE",base:"#DEE2E6",d1:"#B8C4CF",d2:"#8895A7"},blue:{l2:"#EFF8FF",l1:"#AAD4F6",base:"#3183C8",d1:"#2368A2",d2:"#194971"},teal:{l2:"#E7FFFE",l1:"#A8EEEC",base:"#3CAEA3",d1:"#2A9187",d2:"#1B655E"},green:{l2:"#E3FCEC",l1:"#A8EEC1",base:"#38C172",d1:"#249D57",d2:"#187741"},yellow:{l2:"#FFFCF4",l1:"#FDF3D7",base:"#F4CA64",d1:"#CAA53D",d2:"#8C6D1F"},red:{l2:"#FCE8E8",l1:"#F4AAAA",base:"#DC3030",d1:"#B82020",d2:"#881B1B"}},Palette=["#4E79A7","#A0CBE8","#F28E2B","#FFBE7D","#59A14F","#8CD17D","#B6992D","#F1CE63","#499894","#86BCB6","#E15759","#FF9D9A","#79706E","#BAB0AC","#D37295","#FABFD2","#B07AA1","#D4A6C8","#9D7660","#D7B5A6"];try{Graph.displayName="Graph",Graph.__docgenInfo={description:"",displayName:"Graph",props:{layout:{defaultValue:null,description:"",name:"layout",required:!0,type:{name:"StagedLayout"}},animated:{defaultValue:{value:"false"},description:"Whether to run animation during layout process.",name:"animated",required:!1,type:{name:"boolean"}},interactive:{defaultValue:{value:"false"},description:"Whether to allow mouse interaction.",name:"interactive",required:!1,type:{name:"boolean"}},nodeColor:{defaultValue:null,description:"Function to specify color, as a string or an index into the default color palette.",name:"nodeColor",required:!1,type:{name:"(n: Node) => ReactText"}},edgeColor:{defaultValue:null,description:"",name:"edgeColor",required:!1,type:{name:"(e: Edge) => ReactText"}},size:{defaultValue:null,description:"Minimum graph size.",name:"size",required:!1,type:{name:"[number, number]"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["stories/Graph.tsx#Graph"]={docgenInfo:Graph.__docgenInfo,name:"Graph",path:"stories/Graph.tsx#Graph"})}catch(__react_docgen_typescript_loader_error){}},338:function(module,exports,__webpack_require__){__webpack_require__(339),__webpack_require__(450),module.exports=__webpack_require__(451)},361:function(module,exports){},451:function(module,exports,__webpack_require__){"use strict";(function(module){Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__webpack_require__(168),addon_info_1=__webpack_require__(602),addon_knobs_1=__webpack_require__(204);react_1.addDecorator(addon_info_1.withInfo),react_1.addDecorator(addon_knobs_1.withKnobs);const req=__webpack_require__(758);react_1.configure(function loadStories(){req.keys().sort().forEach(req)},module)}).call(this,__webpack_require__(28)(module))},605:function(module,exports,__webpack_require__){var map={"./nestedObjectAssign":291,"./nestedObjectAssign.js":291};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=605},758:function(module,exports,__webpack_require__){var map={"./features.stories.tsx":759,"./force-models.stories.tsx":782};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=758},759:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(168),addon_knobs_1=__webpack_require__(204),schemas_five_1=__webpack_require__(760),src_1=__webpack_require__(328),Graph_1=__webpack_require__(330),schemas_two_1=__webpack_require__(781);function makeLayout(nodeSchemas,edgeSchemas,{steps:steps=200,idealLength:idealLength=30,compactness:compactness=10,forceIterations:forceIterations=1,constraintIterations:constraintIterations=3,extraForces:extraForces,extraConstraints:extraConstraints}){const{nodes:nodes,edges:edges}=src_1.fromSchema(nodeSchemas,edgeSchemas),storage=new src_1.StructuredStorage(nodes,edges),shortestPath=storage.shortestPaths(),forceOptimizer=new src_1.EnergyOptimizer({lrInitial:.3,lrMax:.5,lrMin:.01,wait:20,decay:.9,growth:1.1,smoothing:.5}),constraintOptimizer=new src_1.BasicOptimizer(1);return new src_1.StagedLayout(storage,{steps:steps},{iterations:forceIterations,optimizer:forceOptimizer,generator:function*(storage,step,iter){yield*src_1.generateSpringForces(storage,idealLength,shortestPath),yield*src_1.generateCompactnessForces(storage,compactness),extraForces&&(yield*extraForces(storage,step,iter))}},{iterations:constraintIterations,optimizer:constraintOptimizer,generator:function*(storage,step,iter){for(let u of storage.nodes())yield*src_1.generateNodeChildrenConstraints(u),yield*src_1.generateNodePortConstraints(u);extraConstraints&&(yield*extraConstraints(storage,step,iter))}})}react_2.storiesOf("features",module).add("simple nodes",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesEqual,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("simple nodes (unequal)",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("simple nodes (shapes)",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesShapes,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("disconnected components",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,[],{idealLength:idealLength});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("compound nodes",()=>{const idealLength=addon_knobs_1.number("ideal length",30),compactness=addon_knobs_1.number("group compactness",.5),layout=makeLayout(schemas_five_1.kGraphFive.nodesNested,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength,compactness:compactness});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("compound nodes (shapes)",()=>{const idealLength=addon_knobs_1.number("ideal length",30),compactness=addon_knobs_1.number("group compactness",.5),layout=makeLayout(schemas_five_1.kGraphFive.nodesNestedShapes,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength,compactness:compactness});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("unidirectional flow",()=>{const idealLength=addon_knobs_1.number("ideal length",30),flowSeparation=addon_knobs_1.number("flow separation",50),layout=makeLayout(schemas_five_1.kGraphFive.nodesEqual,schemas_five_1.kGraphFive.edgesAcyclic,{idealLength:idealLength,extraConstraints:function*(storage,step){if(step>10)for(let e of storage.edges())yield src_1.constrainOffset(e.source.node.center,e.target.node.center,">=",flowSeparation,[0,1],{masses:[e.source.node.fixed?1e9:1,e.target.node.fixed?1e9:1]})}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("multidirectional flow",()=>{const idealLength=addon_knobs_1.number("ideal length",30),flowSeparation=addon_knobs_1.number("flow separation",50),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree,{idealLength:idealLength,extraConstraints:function*(storage){function constrain(uid,vid,direction){const u=storage.node(uid),v=storage.node(vid);return src_1.constrainOffset(u.center,v.center,">=",flowSeparation,direction,{masses:[u.fixed?1e9:1,v.fixed?1e9:1]})}yield constrain("n0","n1",[1,0]),yield constrain("n1","n2",[0,1]),yield constrain("n2","n3",[1,0]),yield constrain("n2","n4",[0,1])}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("named ports",()=>{const idealLength=addon_knobs_1.number("ideal length",30),flowSeparation=addon_knobs_1.number("flow separation",50),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal.map(n=>Object.assign({ports:{e1:{location:"east",order:1},w1:{location:"west",order:1},w2:{location:"west",order:2},n1:{location:"north",order:1},s1:{location:"south",order:1},s2:{location:"south",order:2}}},n)),[{id:"e0->1",source:{id:"n0",port:"e1"},target:{id:"n1",port:"w1"}},{id:"e1->2:1",source:{id:"n1",port:"s1"},target:{id:"n2",port:"n1"}},{id:"e1->2:2",source:{id:"n1",port:"s2"},target:{id:"n2",port:"n1"}},{id:"e2->3",source:{id:"n2",port:"e1"},target:{id:"n3",port:"w1"}},{id:"e2->4",source:{id:"n2",port:"s1"},target:{id:"n4",port:"n1"}}],{idealLength:idealLength,extraConstraints:function*(storage){function constrain(uid,vid,direction){const u=storage.node(uid),v=storage.node(vid);return src_1.constrainOffset(u.center,v.center,">=",flowSeparation,direction,{masses:[u.fixed?1e9:1,v.fixed?1e9:1]})}yield constrain("n0","n1",[1,0]),yield constrain("n1","n2",[0,1]),yield constrain("n2","n3",[1,0]),yield constrain("n2","n4",[0,1])}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("oriented edges",()=>{const idealLength=addon_knobs_1.number("ideal length",30),orientationAngle=addon_knobs_1.number("orientation angle",45,{range:!0,min:0,max:360,step:1}),orientationStrength=addon_knobs_1.number("orientation strength",100),layout=makeLayout(schemas_two_1.kGraphTwo.nodes,schemas_two_1.kGraphTwo.edges,{idealLength:idealLength,extraForces:function*(storage){for(let edge of storage.edges())yield src_1.nudgeAngle(edge.source.node.center,edge.target.node.center,orientationAngle,orientationStrength)}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("node distance and offset",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree,{idealLength:idealLength,extraConstraints:function*(storage){yield src_1.constrainNodeOffset(storage.node("n0"),storage.node("n1"),">=",100,[1,1]),yield src_1.constrainNodeDistance(storage.node("n1"),storage.node("n2"),">=",100),yield src_1.constrainNodeOffset(storage.node("n2"),storage.node("n3"),">=",100,[-1,1]),yield src_1.constrainNodeDistance(storage.node("n2"),storage.node("n4"),">=",100,{axis:[1,0]})}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("alignment",()=>{const idealLength=addon_knobs_1.number("ideal length",30),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree,{idealLength:idealLength,extraConstraints:function*(storage){function*align(nodes,axis){yield*src_1.generateNodeAlignmentConstraints(nodes.map(n=>storage.node(n)),axis)}yield*align(["n0","n1"],[1,0]),yield*align(["n1","n2","n4"],[0,1]),yield*align(["n2","n3"],[1,0])}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("grid snap",()=>{const idealLength=addon_knobs_1.number("ideal length",30),gridSnap=addon_knobs_1.boolean("grid snap",!0),gridX=addon_knobs_1.number("grid x",5),gridY=addon_knobs_1.number("grid y",10),layout=makeLayout(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree,{idealLength:idealLength,extraConstraints:function*(storage,step){if(gridSnap&&step>50)for(let u of storage.nodes())yield src_1.constrainNodeGrid(u,gridX,gridY)}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("limp noodle",()=>{const fire=idx=>({nodes:[{id:`n${idx}:group`,shape:{type:"rectangle",width:80,height:80},children:[`n${idx}:conv1`,`n${idx}:relu1`,`n${idx}:conv21`,`n${idx}:conv22`,`n${idx}:relu21`,`n${idx}:relu22`,`n${idx}:cat`]},{id:`n${idx}:conv1`,shape:{type:"rectangle",width:50,height:21}},{id:`n${idx}:relu1`,shape:{type:"rectangle",width:36,height:21}},{id:`n${idx}:conv21`,shape:{type:"rectangle",width:50,height:21}},{id:`n${idx}:conv22`,shape:{type:"rectangle",width:50,height:21}},{id:`n${idx}:relu21`,shape:{type:"rectangle",width:36,height:21}},{id:`n${idx}:relu22`,shape:{type:"rectangle",width:36,height:21}},{id:`n${idx}:cat`,shape:{type:"rectangle",width:71,height:21}}],edges:[{id:`${idx}:c1r1`,source:{id:`n${idx}:conv1`},target:{id:`n${idx}:relu1`}},{id:`${idx}:r1c21`,source:{id:`n${idx}:relu1`},target:{id:`n${idx}:conv21`}},{id:`${idx}:r1c22`,source:{id:`n${idx}:relu1`},target:{id:`n${idx}:conv22`}},{id:`${idx}:c21r21`,source:{id:`n${idx}:conv21`},target:{id:`n${idx}:relu21`}},{id:`${idx}:c22r22`,source:{id:`n${idx}:conv22`},target:{id:`n${idx}:relu22`}},{id:`${idx}:r21cat`,source:{id:`n${idx}:relu21`},target:{id:`n${idx}:cat`}},{id:`${idx}:r22cat`,source:{id:`n${idx}:relu22`},target:{id:`n${idx}:cat`}}]}),nodeSchemas=[...fire(0).nodes,...fire(1).nodes,...fire(2).nodes,...fire(3).nodes,...fire(4).nodes,...fire(5).nodes],edgeSchemas=[...fire(0).edges,...fire(1).edges,...fire(2).edges,...fire(3).edges,...fire(4).edges,...fire(5).edges];nodeSchemas.push({id:"maxpool",shape:{type:"rectangle",width:71,height:21}}),edgeSchemas.push({id:"0:cat1:1conv1",source:{id:"n0:cat"},target:{id:"n1:conv1"}}),edgeSchemas.push({id:"1:cat1:2conv1",source:{id:"n1:cat"},target:{id:"n2:conv1"}}),edgeSchemas.push({id:"2:cat1:3conv1",source:{id:"n2:cat"},target:{id:"n3:conv1"}}),edgeSchemas.push({id:"3:cat1:maxpool",source:{id:"n3:cat"},target:{id:"maxpool"}}),edgeSchemas.push({id:"maxpool:4conv1",source:{id:"maxpool"},target:{id:"n4:conv1"}}),edgeSchemas.push({id:"4:cat1:5conv1",source:{id:"n4:cat"},target:{id:"n5:conv1"}});const idealLength=addon_knobs_1.number("ideal length",20),flowSpacing=addon_knobs_1.number("flow spacing",30),flowStart=addon_knobs_1.number("flow timestep start",0),orientationStrength=addon_knobs_1.number("orient to 90/270",0),layout=makeLayout(nodeSchemas,edgeSchemas,{idealLength:idealLength,compactness:0,forceIterations:1,constraintIterations:5,extraForces:function*(storage){for(let e of storage.edges())yield src_1.nudgeAngle(e.source.node.center,e.target.node.center,[90,270],orientationStrength)},extraConstraints:function*(storage,step){if(step>flowStart)for(let{source:source,target:target}of storage.edges())yield src_1.constrainNodeOffset(source.node,target.node,">=",flowSpacing,[0,1])}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})})}).call(this,__webpack_require__(28)(module))},760:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.kGraphFive={nodesEqual:[{id:"n0",shape:{type:"rectangle",width:20,height:20}},{id:"n1",shape:{type:"rectangle",width:20,height:20}},{id:"n2",shape:{type:"rectangle",width:20,height:20}},{id:"n3",shape:{type:"rectangle",width:20,height:20}},{id:"n4",shape:{type:"rectangle",width:20,height:20}}],nodesUnequal:[{id:"n0",shape:{type:"rectangle",width:20,height:20}},{id:"n1",shape:{type:"rectangle",width:40,height:20}},{id:"n2",shape:{type:"rectangle",width:40,height:40}},{id:"n3",shape:{type:"rectangle",width:20,height:40}},{id:"n4",shape:{type:"rectangle",width:20,height:20}}],nodesShapes:[{id:"n0",shape:{type:"circle",radius:10}},{id:"n1",shape:{type:"rectangle",width:40,height:20}},{id:"n2",shape:{type:"rectangle",width:40,height:40}},{id:"n3",shape:{type:"rectangle",width:20,height:40}},{id:"n4",shape:{type:"circle",radius:10}}],nodesNested:[{id:"n0",shape:{type:"rectangle",width:20,height:20}},{id:"n1",shape:{type:"rectangle",width:20,height:20},children:["n2","n3"]},{id:"n2",shape:{type:"rectangle",width:20,height:20}},{id:"n3",shape:{type:"rectangle",width:20,height:20}},{id:"n4",shape:{type:"rectangle",width:20,height:20}}],nodesNestedShapes:[{id:"n0",shape:{type:"rectangle",width:20,height:20}},{id:"n1",shape:{type:"circle",radius:10},children:["n2","n3"]},{id:"n2",shape:{type:"rectangle",width:20,height:20}},{id:"n3",shape:{type:"circle",radius:10}},{id:"n4",shape:{type:"rectangle",width:20,height:20}}],edgesAcyclic:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e0->2",source:{id:"n0"},target:{id:"n2"}},{id:"e0->3",source:{id:"n0"},target:{id:"n3"}},{id:"e0->4",source:{id:"n0"},target:{id:"n4"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}}],edgesCyclic:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e1->2",source:{id:"n1"},target:{id:"n2"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}},{id:"e3->0",source:{id:"n3"},target:{id:"n0"}},{id:"e3->4",source:{id:"n3"},target:{id:"n4"}}],edgesTree:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e1->2",source:{id:"n1"},target:{id:"n2"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}},{id:"e2->4",source:{id:"n2"},target:{id:"n4"}}]}},761:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class NumberScheduler{constructor(defaultValue=0){this._interpolators=[],this._end=0,this._defaultValue=defaultValue}to(t,fn){if(t<=this._end)throw Error(`Already set in range [0, ${this._end}); got t = ${t}`);return this._interpolators.push([this._end,t,fn]),this._end=t,this}for(deltat,fn){if(deltat<1)throw Error(`New range must be positive; got deltat = ${deltat}`);return this._interpolators.push([this._end,this._end+deltat,fn]),this._end+=deltat,this}get(t){if(t<0||this._end<=t)return this._defaultValue;for(const[start,end,fn]of this._interpolators)if(start<=t&&t<end)return fn((t-start)/(end-start));return this._defaultValue}}function constant(value){return u=>value}function linear(start,end){return u=>(end-start)*u+start}function exponential(start,end,curvature=1){return Math.abs(curvature)<.1?linear(start,end):start<=end?u=>(Math.pow(2,curvature*u)-1)/(Math.pow(2,curvature)-1)*(end-start)+start:u=>(Math.pow(2,curvature*(1-u))-1)/(Math.pow(2,curvature)-1)*(start-end)+end}exports.NumberScheduler=NumberScheduler,exports.constant=constant,exports.linear=linear,exports.exponential=exponential;class BooleanScheduler{constructor(defaultValue=!1){this._values=[],this._end=0,this._defaultValue=defaultValue}to(t,value){if(t<=this._end)throw Error(`Already set in range [0, ${this._end}); got t = ${t}`);return this._values.push([this._end,t,value]),this._end=t,this}for(deltat,value){if(deltat<1)throw Error(`New range must be positive; got deltat = ${deltat}`);return this._values.push([this._end,this._end+deltat,value]),this._end+=deltat,this}get(t){if(t<0||this._end<=t)return this._defaultValue;for(const[start,end,value]of this._values)if(start<=t&&t<end)return value;return this._defaultValue}}exports.BooleanScheduler=BooleanScheduler;try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/scheduler.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/scheduler.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/scheduler.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{NumberScheduler.displayName="NumberScheduler",NumberScheduler.__docgenInfo={description:"A `NumberScheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"NumberScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#NumberScheduler"]={docgenInfo:NumberScheduler.__docgenInfo,name:"NumberScheduler",path:"src/optim/scheduler.ts#NumberScheduler"})}catch(__react_docgen_typescript_loader_error){}try{BooleanScheduler.displayName="BooleanScheduler",BooleanScheduler.__docgenInfo={description:"A `BooleanScheduler` returns some boolean value that changes over time according to a sequence of\nactive ranges.",displayName:"BooleanScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#BooleanScheduler"]={docgenInfo:BooleanScheduler.__docgenInfo,name:"BooleanScheduler",path:"src/optim/scheduler.ts#BooleanScheduler"})}catch(__react_docgen_typescript_loader_error){}},762:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(206);class Vector extends three_1.Vector2{}exports.Vector=Vector;class Gradient{constructor(point,grad){this.point=point,this.grad=grad}}exports.Gradient=Gradient;class Optimizer{}exports.Optimizer=Optimizer;class BasicOptimizer extends Optimizer{constructor(lr=1,decay=1){super(),this.lr=lr,this.decay=decay}step(gradients){gradients.forEach(({grad:grad,point:point})=>point.addScaledVector(grad,this.lr))}update(){this.lr=Math.max(this.lr*this.decay,.01)}}exports.BasicOptimizer=BasicOptimizer;class ScheduledOptimizer extends Optimizer{constructor(scheduler){super(),this.scheduler=scheduler,this._timestep=0,this._lr=scheduler.get(0)}step(gradients){gradients.forEach(({grad:grad,point:point})=>point.addScaledVector(grad,this._lr))}update(){this._timestep+=1,this._lr=this.scheduler.get(this._timestep)}}exports.ScheduledOptimizer=ScheduledOptimizer;class EnergyOptimizer extends Optimizer{constructor(config={}){super(),this._numStepsImproved=0,this._currEnergy=0;const{lrInitial:lrInitial=1,wait:wait=5,lrMax:lrMax=1,lrMin:lrMin=.01,decay:decay=.9,growth:growth=1.1,smoothing:smoothing=.1}=config;if(decay>1)throw Error("Must specify value of `decay` <= 1");if(growth<1)throw Error("Must specify value of `growth` >= 1");if(wait<0)throw Error("Must specify value of `wait` >= 0");this._config={lrInitial:lrInitial,lrMax:lrMax,lrMin:lrMin,wait:wait,decay:decay,growth:growth,smoothing:smoothing},this._lr=lrInitial}step(gradients){let energy=0;gradients.forEach(grad=>{grad.point.add(grad.grad.clone().multiplyScalar(this._lr)),energy+=grad.grad.length()}),energy/=gradients.length+1,this._currEnergy+=energy}update(){this._prevEnergy||(this._prevEnergy=this._currEnergy),this._currEnergy<this._prevEnergy?(this._numStepsImproved+=1,this._numStepsImproved>=this._config.wait&&(this._numStepsImproved=0,this._lr=Math.min(this._config.growth*this._lr,this._config.lrMax))):this._currEnergy>this._prevEnergy&&(this._numStepsImproved=0,this._lr=Math.max(this._config.decay*this._lr,this._config.lrMin)),this._prevEnergy*=this._config.smoothing,this._prevEnergy+=(1-this._config.smoothing)*this._currEnergy,this._currEnergy=0}}exports.EnergyOptimizer=EnergyOptimizer;class RMSPropOptimizer extends Optimizer{constructor(lr=1,smoothing=.99){super(),this.lr=lr,this.smoothing=smoothing,this._square_avgs=new Map}step(gradients){gradients.forEach(({grad:grad,point:point})=>{let square_avg=this._square_avgs.get(point)||new Vector(0,0);square_avg=square_avg.multiplyScalar(this.smoothing).addScaledVector(grad.clone().multiply(grad),1-this.smoothing),this._square_avgs.set(point,square_avg),point.x+=this.lr*grad.x/(Math.sqrt(square_avg.x)+.001),point.y+=this.lr*grad.y/(Math.sqrt(square_avg.y)+.001)})}update(){}}exports.RMSPropOptimizer=RMSPropOptimizer;class TrustRegionOptimizer extends Optimizer{constructor(lr=.6,adaption=.1,smoothing=.5,lrMax=1,lrMin=1e-5){super(),this.lr=lr,this.adaption=adaption,this.smoothing=smoothing,this.lrMax=lrMax,this.lrMin=lrMin,this._norm_avgs=new Map,this._lrs=new Map}step(gradients){gradients.forEach(({grad:grad,point:point})=>{let norm_avg=this._norm_avgs.get(point)||grad.length();norm_avg=norm_avg*this.smoothing+grad.length()*(1-this.smoothing),this._norm_avgs.set(point,norm_avg);let lr=this._lrs.get(point)||this.lr;lr=grad.length()/(norm_avg+.001)>=.5?Math.min(this.lrMax,(1+this.adaption)*lr):Math.max(this.lrMin,(1-this.adaption)*lr),this._lrs.set(point,lr),point.addScaledVector(grad,lr)})}update(){}}exports.TrustRegionOptimizer=TrustRegionOptimizer;try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/optimizer.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/optimizer.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/optimizer.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/optimizer.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{ScheduledOptimizer.displayName="ScheduledOptimizer",ScheduledOptimizer.__docgenInfo={description:"A `ScheduledOptimizer` uses a variable learning rate set by a `Scheduler`.",displayName:"ScheduledOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#ScheduledOptimizer"]={docgenInfo:ScheduledOptimizer.__docgenInfo,name:"ScheduledOptimizer",path:"src/optim/optimizer.ts#ScheduledOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{EnergyOptimizer.displayName="EnergyOptimizer",EnergyOptimizer.__docgenInfo={description:"A `EnergyOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before). The energy function\nis the squared norm of all the gradients between successive `update()` calls.",displayName:"EnergyOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#EnergyOptimizer"]={docgenInfo:EnergyOptimizer.__docgenInfo,name:"EnergyOptimizer",path:"src/optim/optimizer.ts#EnergyOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{RMSPropOptimizer.displayName="RMSPropOptimizer",RMSPropOptimizer.__docgenInfo={description:"A `RMSPropOptimizer` uses an adaptive scheme based on a per-parameter moving weighted average of\nmagnitudes.",displayName:"RMSPropOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#RMSPropOptimizer"]={docgenInfo:RMSPropOptimizer.__docgenInfo,name:"RMSPropOptimizer",path:"src/optim/optimizer.ts#RMSPropOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme that increasing the learning rate if the\ngradients are growing, and decreasing the learning rate if the gradients are shrinking.",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/optimizer.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}},763:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(764)),__export(__webpack_require__(329)),__export(__webpack_require__(777)),__export(__webpack_require__(779)),__export(__webpack_require__(780));try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas\n@param config `shapeCreator`: Function converting `ShapeSchema` to `Shape`.\n`portLocation`: Location to assign to port if unspecified. (default: 'center')",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or 2-array of gradients in order `[p, q]`.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`.\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.\n@returns     Empty array (if already satisfied) or tuple of gradients in order `[p, q]`.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{nudgeAngle.displayName="nudgeAngle",nudgeAngle.__docgenInfo={description:"Nudges the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. The angle is measured counterclockwise from 0 (as\nin trigonometry) but since browser's render the positive-y direction pointing downwards, the\nresult may appear opposite than intended if unaccounted for.\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle Single angle or array of angles, in degrees within range [0, 360].\n@param strength Maximum restoring force (felt when points directly opposite the desired angle).\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgeAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#nudgeAngle"]={docgenInfo:nudgeAngle.__docgenInfo,name:"nudgeAngle",path:"src/graph/index.ts#nudgeAngle"})}catch(__react_docgen_typescript_loader_error){}try{nudgePair.displayName="nudgePair",nudgePair.__docgenInfo={description:"Nudges the pair of points in opposite directions, away from each other if `magnitude` is\npositive, and towards each other if the `magnitude` is negative. It is possible to specify\ndifferent `magnitude` for each point.\n@param p Point vector.\n@param q Point vector.\n@param magnitude Single magnitude or tuple of magnitudes. Nudges away from each other if positive, and\nnudges towards each other if negative.\n@returns     Tuple of gradients in order `[p, q]`.",displayName:"nudgePair",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#nudgePair"]={docgenInfo:nudgePair.__docgenInfo,name:"nudgePair",path:"src/graph/index.ts#nudgePair"})}catch(__react_docgen_typescript_loader_error){}try{nudgePoint.displayName="nudgePoint",nudgePoint.__docgenInfo={description:"Nudges a point (or array of points) in the specified `direction` with `magnitude`.\n@param points Point vector or array of point vectors.\n@param magnitude Magnitude scalar.\n@param direction Direction vector, unnormalized.\n@returns     Array of gradients for each point.",displayName:"nudgePoint",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#nudgePoint"]={docgenInfo:nudgePoint.__docgenInfo,name:"nudgePoint",path:"src/graph/index.ts#nudgePoint"})}catch(__react_docgen_typescript_loader_error){}try{generateNodePortConstraints.displayName="generateNodePortConstraints",generateNodePortConstraints.__docgenInfo={description:"Constrains `u`'s ports (if any) to be at their correct `location` on the node's boundary,\nin their correct `order` relative to other ports, if specified. If no port is specified\n@param u Node with ports to constrain.\n@param centering Strength of port attraction towards center of each side. (default: 0.1)\n@param gap Minimum distance between successive ports at a location. (default: 8)",displayName:"generateNodePortConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateNodePortConstraints"]={docgenInfo:generateNodePortConstraints.__docgenInfo,name:"generateNodePortConstraints",path:"src/graph/index.ts#generateNodePortConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeNonoverlap.displayName="constrainNodeNonoverlap",constrainNodeNonoverlap.__docgenInfo={description:"@param u First node of pair to ensure nonoverlap.\n@param v Second node of pair to ensure nonoverlap.\n@param margin Spacing outside each node's boundary.",displayName:"constrainNodeNonoverlap",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainNodeNonoverlap"]={docgenInfo:constrainNodeNonoverlap.__docgenInfo,name:"constrainNodeNonoverlap",path:"src/graph/index.ts#constrainNodeNonoverlap"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeAlignmentConstraints.displayName="generateNodeAlignmentConstraints",generateNodeAlignmentConstraints.__docgenInfo={description:"@param nodes\n@param axis",displayName:"generateNodeAlignmentConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateNodeAlignmentConstraints"]={docgenInfo:generateNodeAlignmentConstraints.__docgenInfo,name:"generateNodeAlignmentConstraints",path:"src/graph/index.ts#generateNodeAlignmentConstraints"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeDistance.displayName="constrainNodeDistance",constrainNodeDistance.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainNodeDistance"]={docgenInfo:constrainNodeDistance.__docgenInfo,name:"constrainNodeDistance",path:"src/graph/index.ts#constrainNodeDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeOffset.displayName="constrainNodeOffset",constrainNodeOffset.__docgenInfo={description:"Constraint two nodes such that the distance between their support points along a given axis obeys a given inequality.\n@param u\n@param v\n@param op\n@param separation\n@param config",displayName:"constrainNodeOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainNodeOffset"]={docgenInfo:constrainNodeOffset.__docgenInfo,name:"constrainNodeOffset",path:"src/graph/index.ts#constrainNodeOffset"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeCircular.displayName="constrainNodeCircular",constrainNodeCircular.__docgenInfo={description:"@param u\n@param v",displayName:"constrainNodeCircular",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainNodeCircular"]={docgenInfo:constrainNodeCircular.__docgenInfo,name:"constrainNodeCircular",path:"src/graph/index.ts#constrainNodeCircular"})}catch(__react_docgen_typescript_loader_error){}try{constrainNodeGrid.displayName="constrainNodeGrid",constrainNodeGrid.__docgenInfo={description:"@param u\n@param dx\n@param dy",displayName:"constrainNodeGrid",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainNodeGrid"]={docgenInfo:constrainNodeGrid.__docgenInfo,name:"constrainNodeGrid",path:"src/graph/index.ts#constrainNodeGrid"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/graph/index.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{StagedLayout.displayName="StagedLayout",StagedLayout.__docgenInfo={description:"A `StagedLayout` performs a fixed number of optimization steps, where each step involved\nexecuting all stages of a computation. A single stage uses a generator function to generate\ngradients, which optimizer applies. Each stage may be repeated for a different fixed number\nof iterations.",displayName:"StagedLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#StagedLayout"]={docgenInfo:StagedLayout.__docgenInfo,name:"StagedLayout",path:"src/graph/index.ts#StagedLayout"})}catch(__react_docgen_typescript_loader_error){}try{generateSpringForces.displayName="generateSpringForces",generateSpringForces.__docgenInfo={description:"Generates (1) attractive forces encouraging connected nodes to be no farther than their ideal\ndistance, and (2) repulsive forces between unconnected nodes encouraging them to be no closer\nthan their ideal distance. The ideal distance is the shortest path length scaled by the ideal\nlength. There are no forces generated between nodes of different connected components (with\nundefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a non-undefined `shortestPath`.\n@param shortestPath",displayName:"generateSpringForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateSpringForces"]={docgenInfo:generateSpringForces.__docgenInfo,name:"generateSpringForces",path:"src/graph/index.ts#generateSpringForces"})}catch(__react_docgen_typescript_loader_error){}try{generateSpringElectricalForces.displayName="generateSpringElectricalForces",generateSpringElectricalForces.__docgenInfo={description:"Generates attractive forces encouraging edges to be no fthe ideal length and repulsive forces between\nunconnected nodes proportional to their shortest path length. There are no forces generated\nbetween forces from different connected components (with undefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a direct edge.\n@param shortestPath",displayName:"generateSpringElectricalForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateSpringElectricalForces"]={docgenInfo:generateSpringElectricalForces.__docgenInfo,name:"generateSpringElectricalForces",path:"src/graph/index.ts#generateSpringElectricalForces"})}catch(__react_docgen_typescript_loader_error){}try{generateCompactnessForces.displayName="generateCompactnessForces",generateCompactnessForces.__docgenInfo={description:"Generates forces that pull children nodes towards the parent's center.\n@param storage\n@param strength",displayName:"generateCompactnessForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateCompactnessForces"]={docgenInfo:generateCompactnessForces.__docgenInfo,name:"generateCompactnessForces",path:"src/graph/index.ts#generateCompactnessForces"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeChildrenConstraints.displayName="generateNodeChildrenConstraints",generateNodeChildrenConstraints.__docgenInfo={description:"Constrain `u`'s children to be contained within itself, expansing its boundaries if necessary.\n@param u Node with children to constrain.\n@param padding Spacing inside the node's boundary.",displayName:"generateNodeChildrenConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#generateNodeChildrenConstraints"]={docgenInfo:generateNodeChildrenConstraints.__docgenInfo,name:"generateNodeChildrenConstraints",path:"src/graph/index.ts#generateNodeChildrenConstraints"})}catch(__react_docgen_typescript_loader_error){}},764:function(module,exports,__webpack_require__){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(86),shapes_1=__webpack_require__(765),lodash_1=__webpack_require__(767),seedrandom_1=__importDefault(__webpack_require__(768)),kPortOffset=.2;function fromSchema(nodeSchemas,edgeSchemas,{shapeCreator:shapeCreator=shapes_1.fromShapeSchema,portLocation:portLocation="center"}={}){const nodeIdToIdx=new Map,nodes=nodeSchemas.map(({id:id,center:center,shape:shape,fixed:fixed,children:children,ports:ports,meta:meta},idx)=>{if(!id)throw Error(`Invalid NodeId: ${id}`);if(nodeIdToIdx.has(id))throw Error(`Duplicate NodeId: ${id}`);nodeIdToIdx.set(id,idx);const rand=seedrandom_1.default(id),centerpt=center?new optim_1.Vector(center.x,center.y):new optim_1.Vector(rand(),rand());return{id:id,center:centerpt,shape:shapeCreator(shape||{type:"rectangle",width:1,height:1},centerpt),fixed:fixed||!1,children:children||[],ports:ports?lodash_1.mapValues(ports,({location:location,order:order,point:point})=>({location:location||portLocation,order:order,point:point?new optim_1.Vector(point.x,point.y):new optim_1.Vector(centerpt.x+kPortOffset*rand(),centerpt.y+kPortOffset*rand())})):{},meta:meta}});function processEndpoint(edgeId,type,nodeId,port){const idx=nodeIdToIdx.get(nodeId);if(void 0===idx)throw Error(`Invalid ${type} NodeId: ${nodeId}, edge ${edgeId}`);const node=nodes[idx];let point;if(port){if(!(port in node.ports))throw Error(`Invalid ${type} port name: ${port}, ${type} ${nodeId}, edge ${edgeId}`);point=node.ports[port].point}else{const rand=seedrandom_1.default(`${edgeId}-${type}`);port=`_${edgeId}`,point=new optim_1.Vector(node.center.x+kPortOffset*rand(),node.center.y+kPortOffset*rand()),node.ports[port]={point:point,location:portLocation}}return{id:nodeId,port:port,node:node,point:point}}nodes.forEach(node=>node.children=node.children.map(id=>{const childIdx=nodeIdToIdx.get(id);if(void 0===childIdx)throw Error(`Invalid child NodeId: ${id}, parent ${node.id}`);return nodes[childIdx]}));const edgeIdToIdx=new Set,edges=edgeSchemas.map(({id:id,source:source,target:target,path:path,meta:meta})=>{if(!id)throw Error(`Invalid EdgeId: ${id}`);if(edgeIdToIdx.has(id))throw Error(`Duplicate EdgeId: ${id}`);edgeIdToIdx.add(id);const s=processEndpoint(id,"source",source.id,source.port),t=processEndpoint(id,"target",target.id,target.port);return{id:id,source:s,target:t,path:path?path.map(({x:x,y:y})=>new optim_1.Vector(x,y)):[s.point,t.point],meta:meta}});return{nodes:nodes,edges:edges}}exports.fromSchema=fromSchema,exports.toSchema=function toSchema(nodes,edges){return{nodeSchemas:nodes.map(node=>({id:node.id,center:{x:node.center.x,y:node.center.y},shape:node.shape.toSchema(),fixed:node.fixed,children:node.children.map(child=>child.id),ports:Object.fromEntries(Object.entries(node.ports).map(([name,{location:location,order:order,point:point}])=>[name,{location:location,order:order,point:{x:point.x,y:point.y}}])),meta:node.meta})),edgeSchemas:edges.map(edge=>({id:edge.id,source:{id:edge.source.id,port:edge.source.port},target:{id:edge.target.id,port:edge.target.port},path:edge.path.map(point=>({x:point.x,y:point.y})),meta:edge.meta}))}};try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas\n@param config `shapeCreator`: Function converting `ShapeSchema` to `Shape`.\n`portLocation`: Location to assign to port if unspecified. (default: 'center')",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/elements.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/elements.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}},765:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(86),sat_1=__webpack_require__(766),three_1=__webpack_require__(206);class Shape{constructor(center,preserve){this.center=center,this.preserve=preserve}}exports.Shape=Shape,exports.fromShapeSchema=function fromShapeSchema(schema,center){const{type:type,preserve:preserve}=schema;switch(type){case"rectangle":{const{width:width,height:height}=schema;return new Rectangle(center,width,height,preserve)}case"circle":{const{radius:radius}=schema;return new Circle(center,radius,preserve)}default:throw Error(`Unrecognized ShapeSchema type: ${type}`)}};class Rectangle extends Shape{constructor(center,width,height,preserve){super(center,preserve),this.control=new optim_1.Vector(width/2,height/2)}bounds(){return{x:this.center.x-this.control.x,X:this.center.x+this.control.x,y:this.center.y-this.control.y,Y:this.center.y+this.control.y,width:2*this.control.x,height:2*this.control.y}}boundary(direction,offset=0){for(let[start,end]of this._edges(offset)){const pt=intersectSegment(start,end,direction);if(void 0!==pt)return pt.add(this.center)}throw Error(`No boundary point found: direction ${JSON.stringify(direction)}, edges ${JSON.stringify(this._edges())}`)}support(direction){let support,max=Number.NEGATIVE_INFINITY;for(let vertex of this._vertices()){const dot=vertex.dot(direction);dot>max&&(support=vertex,max=dot)}if(!support)throw Error(`No support point found: direction ${direction}`);return support.add(this.center)}contains(point,offset=0){return point.x<=this.center.x+this.control.x+offset&&point.x>=this.center.x-this.control.x-offset&&point.y<=this.center.y+this.control.y+offset&&point.y>=this.center.y-this.control.y-offset}constrainShapeCompact(subshapes,offset=0){let box=new three_1.Box2;subshapes.forEach(subshape=>{const{x:x,y:y,X:X,Y:Y}=subshape.bounds();box.union(new three_1.Box2(new optim_1.Vector(x,y),new optim_1.Vector(X,Y)))}),box.expandByScalar(offset);const centerGrad=(new optim_1.Vector).subVectors(box.getCenter(new optim_1.Vector),this.center),controlGrad=(new optim_1.Vector).subVectors(box.max,(new optim_1.Vector).addVectors(this.control,this.center));return[new optim_1.Gradient(this.center,centerGrad),new optim_1.Gradient(this.control,controlGrad)]}constrainShapeWithin(subshape,{masses:masses={shape:1,subshape:1},expansion:expansion=0,offset:offset=0}={}){let maxPointGrad,maxCenterGrad,maxPointGradLen=Number.NEGATIVE_INFINITY,maxCenterGradLen=Number.NEGATIVE_INFINITY,maxControlGradLen=Number.NEGATIVE_INFINITY,maxControlGrad=void 0;for(let normal of[[0,1],[1,0],[0,-1],[-1,0]]){const support=subshape.support(new optim_1.Vector(normal[0],normal[1])),g=this.constrainPointWithin(support,{masses:{shape:masses.shape,point:masses.subshape},expansion:expansion,offset:offset});if(0===g.length)continue;const[pointGrad,centerGrad,controlGrad]=g;pointGrad.grad.length()>maxPointGradLen&&(maxPointGrad=pointGrad,maxPointGradLen=pointGrad.grad.length()),centerGrad.grad.length()>maxCenterGradLen&&(maxCenterGrad=centerGrad,maxCenterGradLen=centerGrad.grad.length()),controlGrad.grad.length()>maxControlGradLen&&(maxControlGrad=controlGrad,maxControlGradLen=controlGrad.grad.length())}const grads=[];return void 0!==maxPointGrad&&grads.push(new optim_1.Gradient(subshape.center,maxPointGrad.grad)),void 0!==maxCenterGrad&&grads.push(maxCenterGrad),void 0!==maxControlGrad&&grads.push(maxControlGrad),grads}constrainPointWithin(point,{masses:masses={shape:1,point:1},expansion:expansion=0,offset:offset=0}={}){return this.contains(point,offset)?[]:this.constrainPointOnBoundary(point,{masses:masses,expansion:expansion,offset:offset})}constrainPointOnBoundary(point,{masses:masses={shape:1,point:1},expansion:expansion=0,offset:offset=0}={}){const centerToPoint=(new optim_1.Vector).subVectors(point,this.center),boundary=this.boundary(centerToPoint,offset).sub(this.center),boundaryToPointOffset=centerToPoint.length()-boundary.length(),pointDelta=-boundaryToPointOffset*(masses.shape/(masses.shape+masses.point)),shapeDelta=boundaryToPointOffset*(masses.point/(masses.shape+masses.point)),centerDelta=shapeDelta*(1-expansion),boundaryDelta=shapeDelta*expansion;return centerToPoint.normalize(),[new optim_1.Gradient(point,centerToPoint.clone().multiplyScalar(pointDelta)),new optim_1.Gradient(this.center,centerToPoint.clone().multiplyScalar(centerDelta)),new optim_1.Gradient(this.control,this.control.clone().multiplyScalar(boundaryDelta/boundary.length()))]}toCollidable(){return new sat_1.Polygon(new sat_1.Vector(this.center.x,this.center.y),this._vertices().map(vec=>new sat_1.Vector(vec.x,vec.y)))}toSchema(){const{preserve:preserve}=this,{width:width,height:height}=this.bounds();return{type:"rectangle",preserve:preserve,width:width,height:height}}_edges(offset=0){const{x:halfwidth,y:halfheight}=this.control,x=-halfwidth-offset,X=halfwidth+offset,y=-halfheight-offset,Y=halfheight+offset;return[[new optim_1.Vector(x,y),new optim_1.Vector(X,y)],[new optim_1.Vector(x,Y),new optim_1.Vector(X,Y)],[new optim_1.Vector(x,y),new optim_1.Vector(x,Y)],[new optim_1.Vector(X,y),new optim_1.Vector(X,Y)]]}_vertices(offset=0){const{x:halfwidth,y:halfheight}=this.control,x=-halfwidth-offset,X=halfwidth+offset,y=-halfheight-offset,Y=halfheight+offset;return[new optim_1.Vector(x,y),new optim_1.Vector(X,y),new optim_1.Vector(X,Y),new optim_1.Vector(x,Y)]}}exports.Rectangle=Rectangle;class Circle extends Shape{constructor(center,radius,preserve){super(center,preserve),this.radius=new optim_1.Vector(radius,0)}bounds(){return{x:this.center.x-this.radius.x,X:this.center.x+this.radius.x,y:this.center.y-this.radius.x,Y:this.center.y+this.radius.x,width:2*this.radius.x,height:2*this.radius.x}}boundary(direction,offset=0){return direction.clone().setLength(this.radius.x).add(this.center)}support(direction,offset=0){return this.boundary(direction)}contains(point,offset=0){return(new optim_1.Vector).subVectors(point,this.center).length()<this.radius.x}constrainShapeCompact(subshapes,offset=0){let box=new three_1.Box2;subshapes.forEach(subshape=>{const{x:x,y:y,X:X,Y:Y}=subshape.bounds();box.union(new three_1.Box2(new optim_1.Vector(x,y),new optim_1.Vector(X,Y)))}),box.expandByScalar(offset);const centerGrad=(new optim_1.Vector).subVectors(box.getCenter(new optim_1.Vector),this.center),controlGrad=(new optim_1.Vector).subVectors(new optim_1.Vector(box.getSize(new optim_1.Vector).multiplyScalar(.5).length(),0),this.radius);return[new optim_1.Gradient(this.center,centerGrad),new optim_1.Gradient(this.radius,controlGrad)]}constrainShapeWithin(subshape,{masses:masses={shape:1,subshape:1},expansion:expansion=0,offset:offset=0}={}){const{x:x,y:y,X:X,Y:Y}=subshape.bounds(),farthestPoint=new optim_1.Vector(X,Y);return Math.abs(x-this.center.x)>Math.abs(X-this.center.x)&&(farthestPoint.x=x),Math.abs(y-this.center.y)>Math.abs(Y-this.center.y)&&(farthestPoint.y=y),this.constrainPointWithin(farthestPoint,{masses:{shape:masses.shape,point:masses.subshape},expansion:expansion,offset:offset})}constrainPointWithin(point,{masses:masses={shape:1,point:1},expansion:expansion=0,offset:offset=0}={}){return this.contains(point,offset)?[]:this.constrainPointOnBoundary(point,{masses:masses,expansion:expansion,offset:offset})}constrainPointOnBoundary(point,{masses:masses={shape:1,point:1},expansion:expansion=0,offset:offset=0}={}){const centerToPoint=(new optim_1.Vector).subVectors(point,this.center),boundary=this.boundary(centerToPoint,offset).sub(this.center),boundaryToPointOffset=centerToPoint.length()-boundary.length(),pointDelta=-boundaryToPointOffset*(masses.shape/(masses.shape+masses.point)),shapeDelta=boundaryToPointOffset*(masses.point/(masses.shape+masses.point)),centerDelta=shapeDelta*(1-expansion),boundaryDelta=shapeDelta*expansion;return centerToPoint.normalize(),[new optim_1.Gradient(point,centerToPoint.clone().multiplyScalar(pointDelta)),new optim_1.Gradient(this.center,centerToPoint.clone().multiplyScalar(centerDelta)),new optim_1.Gradient(this.radius,this.radius.clone().multiplyScalar(boundaryDelta/boundary.length()))]}toCollidable(){return new sat_1.Circle(new sat_1.Vector(this.center.x,this.center.y),this.radius.x)}toSchema(){const{preserve:preserve}=this;return{type:"circle",preserve:preserve,radius:this.radius.x}}}function intersectSegment(start,end,ray){const delta=(new optim_1.Vector).subVectors(end,start),denom=ray.y*delta.x-ray.x*delta.y;if(Math.abs(denom)<1e-6)return;const t=(ray.x*start.y-ray.y*start.x)/denom,s=(delta.x*start.y-delta.y*start.x)/denom;return t<0||1<t||s<0?void 0:start.clone().multiplyScalar(1-t).addScaledVector(end,t)}exports.Circle=Circle;try{Shape.displayName="Shape",Shape.__docgenInfo={description:"A `Shape` represents a convex boundary of a node. It has preferred dimensions, but these may be\nexpanded in order to contain children nodes. Optionally, it can have padding (inside) or margin\n(outside) of the boundary.",displayName:"Shape",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/shapes.ts#Shape"]={docgenInfo:Shape.__docgenInfo,name:"Shape",path:"src/graph/shapes.ts#Shape"})}catch(__react_docgen_typescript_loader_error){}},776:function(module,exports){},777:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils_1=__webpack_require__(778);class Storage{}exports.Storage=Storage;class BasicStorage extends Storage{constructor(nodes,edges){super(),this._nodes=nodes,this._edges=edges,this._nodeIdToIdx=new Map(nodes.map(({id:id},idx)=>[id,idx])),this._edgeIdToIdx=new Map(edges.map(({id:id},idx)=>[id,idx]))}nodes(){return Array.from(this._nodes)}edges(){return Array.from(this._edges)}node(id){const idx=this._nodeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Node with specified NodeId: ${id}`);return this._nodes[idx]}edge(id){const idx=this._edgeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Edge with specified EdgeId: ${id}`);return this._edges[idx]}bounds(){if(0==this._nodes.length)return{x:0,y:0,X:0,Y:0,width:0,height:0};let x=Number.POSITIVE_INFINITY,y=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY,Y=Number.NEGATIVE_INFINITY;return this._nodes.forEach(node=>{const bounds=node.shape.bounds();x=Math.min(x,bounds.x),y=Math.min(y,bounds.y),X=Math.max(X,bounds.X),Y=Math.max(Y,bounds.Y)}),this._edges.forEach(edge=>{const xs=edge.path.map(pt=>pt.x),ys=edge.path.map(pt=>pt.y);x=Math.min(x,...xs),y=Math.min(y,...ys),X=Math.max(X,...xs),Y=Math.max(Y,...ys)}),{x:x,y:y,X:X,Y:Y,width:X-x,height:Y-y}}}exports.BasicStorage=BasicStorage;class StructuredStorage extends BasicStorage{constructor(nodes,edges){super(nodes,edges),this._roots=new Set,this._parents=new Map,nodes.forEach(node=>{this._roots.add(node),node.children.forEach(child=>{if(this._parents.has(child))throw Error(`Node can only have 1 parent: child NodeId ${child.id}, parent NodeId ${node.id}`);this._parents.set(child,node)})});for(let child of this._parents.keys())this._roots.delete(child);this._edgesFrom=new Map,this._edgesTo=new Map,edges.forEach(edge=>{const edgesFromSource=this._edgesFrom.get(edge.source.node);void 0===edgesFromSource?this._edgesFrom.set(edge.source.node,[edge]):edgesFromSource.push(edge);const edgesToTarget=this._edgesTo.get(edge.target.node);void 0===edgesToTarget?this._edgesTo.set(edge.target.node,[edge]):edgesToTarget.push(edge)})}parents(ns){utils_1.isIterable(ns)||(ns=[ns]);const parents=new Set;for(let node of ns){const parent=this._parents.get(node);parent&&parents.add(parent)}return parents}siblings(ns){utils_1.isIterable(ns)||(ns=[ns]);const siblings=new Set;for(let node of ns){const parent=this._parents.get(node);parent?parent.children.forEach(root=>siblings.add(root)):this._roots.forEach(root=>siblings.add(root)),siblings.delete(node)}return siblings}children(ns){return utils_1.isIterable(ns)?new Set(Array.from(ns).flatMap(n=>n.children)):new Set(ns.children)}roots(){return this._roots}ancestors(ns,{levels:levels,until:until}={}){utils_1.isIterable(ns)||(ns=[ns]);const ancestors=new Set,visited=new Set,traverse=(u,level)=>{void 0!==u&&(void 0!==levels&&level>levels||visited.has(u)||(visited.add(u),ancestors.add(u),u!==until&&traverse(this._parents.get(u),level+1)))};for(let node of ns)traverse(this._parents.get(node),1);return ancestors}descendants(ns,levels){utils_1.isIterable(ns)||(ns=[ns]);const descendants=new Set,visited=new Set,traverse=(u,level)=>{void 0!==levels&&level>levels||visited.has(u)||(visited.add(u),descendants.add(u),u.children.forEach(child=>traverse(child,level+1)))};for(let node of ns)node.children.forEach(child=>traverse(child,1));return descendants}hasAncestor(n,ancestor){let curr=this._parents.get(n);for(;;){if(void 0===curr)return!1;if(curr===ancestor)return!0;curr=this._parents.get(curr)}}hasDescendant(n,descendant){return this.hasAncestor(descendant,n)}leastCommonAncestor(u,v){const visited=new Set;let left=u,right=v;for(;left||right;){if(left){if(visited.has(left))return left;visited.add(left),left=this._parents.get(left)}if(right){if(visited.has(right))return right;visited.add(right),right=this._parents.get(right)}}}neighbors(ns){return utils_1.setUnion(this.sources(ns),this.targets(ns))}sources(ns){const sources=new Set;return this.edgesTo(ns).forEach(e=>sources.add(e.source.node)),sources}targets(ns){const targets=new Set;return this.edgesFrom(ns).forEach(e=>targets.add(e.target.node)),targets}edgesTo(ns){utils_1.isIterable(ns)||(ns=[ns]);const edgesTo=new Set;for(let node of ns){const es=this._edgesTo.get(node);es&&es.forEach(e=>edgesTo.add(e))}return edgesTo}edgesFrom(ns){utils_1.isIterable(ns)||(ns=[ns]);const edgesFrom=new Set;for(let node of ns){const es=this._edgesFrom.get(node);es&&es.forEach(e=>edgesFrom.add(e))}return edgesFrom}existsEdge(u,v,undirected=!1){const edgesFrom=this._edgesFrom.get(u);if(edgesFrom)for(let e of edgesFrom)if(e.target.node===v)return!0;if(undirected){const edgesTo=this._edgesTo.get(u);if(edgesTo)for(let e of edgesTo)if(e.source.node===v)return!0}return!1}connectedComponents(){return new Set}shortestPaths(directed=!1){const dist=new Map;let sources,targets,intermediates;this._edges.forEach(edge=>{dist.set(`${edge.source.id}|${edge.target.id}`,1),directed||dist.set(`${edge.target.id}|${edge.source.id}`,1)}),directed?(sources=this.sources(this.nodes()),targets=this.targets(this.nodes()),intermediates=utils_1.setIntersection(sources,targets)):sources=targets=intermediates=this.neighbors(this.nodes());for(let k of intermediates)for(let i of sources)for(let j of targets){let dist_ij=i===j?0:dist.get(`${i.id}|${j.id}`)||Number.POSITIVE_INFINITY,dist_ik=i===k?0:dist.get(`${i.id}|${k.id}`)||Number.POSITIVE_INFINITY,dist_kj=k===j?0:dist.get(`${k.id}|${j.id}`)||Number.POSITIVE_INFINITY;const dist_ij_new=Math.min(dist_ij,dist_ik+dist_kj);Number.isFinite(dist_ij_new)&&dist.set(`${i.id}|${j.id}`,dist_ij_new)}return(u,v)=>u===v?0:dist.get(`${u.id}|${v.id}`)}}exports.StructuredStorage=StructuredStorage;try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/storage.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/storage.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/graph/storage.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}},778:function(module,exports,__webpack_require__){"use strict";function isIterable(obj){return null!=obj&&"function"==typeof obj[Symbol.iterator]}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isIterable=isIterable,exports.setIntersection=function setIntersection(x,y){const intersection=new Set;return x.size<y.size?x.forEach(elem=>{y.has(elem)&&intersection.add(elem)}):y.forEach(elem=>{x.has(elem)&&intersection.add(elem)}),intersection},exports.setUnion=function setUnion(x,y){return new Set([...x,...y])};try{isIterable.displayName="isIterable",isIterable.__docgenInfo={description:"",displayName:"isIterable",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/utils.ts#isIterable"]={docgenInfo:isIterable.__docgenInfo,name:"isIterable",path:"src/graph/utils.ts#isIterable"})}catch(__react_docgen_typescript_loader_error){}},779:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Layout{constructor(storage){this.storage=storage}}exports.Layout=Layout;class StagedLayout extends Layout{constructor(storage,{steps:steps=1,onStart:onStart=(()=>!0),onStep:onStep=(()=>!0),onEnd:onEnd=(()=>void 0)},...stages){super(storage),this.onStart=onStart,this.onStep=onStep,this.onEnd=onEnd,this.stages=stages,this._totalSteps=steps,this._finishedSteps=0}start(){const{onStart:onStart,onEnd:onEnd}=this;if(onStart(this.storage,this._finishedSteps)){for(;this._finishedSteps<this._totalSteps;)if(this._finishedSteps+=1,!1===this.step())return;onEnd(this.storage,this._finishedSteps)}}step(){const{onStep:onStep}=this;for(let stage of this.stages)for(let i=1;i<=stage.iterations;i++){const gen=stage.generator(this.storage,this._finishedSteps,i);let grads;for(;(grads=gen.next()).value&&stage.optimizer.step(grads.value),!grads.done;);stage.optimizer.update()}return onStep(this.storage,this._finishedSteps)}}exports.StagedLayout=StagedLayout;try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/layout.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{StagedLayout.displayName="StagedLayout",StagedLayout.__docgenInfo={description:"A `StagedLayout` performs a fixed number of optimization steps, where each step involved\nexecuting all stages of a computation. A single stage uses a generator function to generate\ngradients, which optimizer applies. Each stage may be repeated for a different fixed number\nof iterations.",displayName:"StagedLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#StagedLayout"]={docgenInfo:StagedLayout.__docgenInfo,name:"StagedLayout",path:"src/graph/layout.ts#StagedLayout"})}catch(__react_docgen_typescript_loader_error){}},780:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(86),gradients_1=__webpack_require__(329);function*generateSpringForces(storage,idealLength,shortestPath){const visited=new Set;for(let u of storage.nodes()){visited.add(u);for(let v of storage.nodes()){if(visited.has(v))continue;if(u.fixed&&v.fixed)continue;const[wu,wv]=[u.fixed?0:1,v.fixed?0:1];if(storage.hasAncestor(u,v)||storage.hasAncestor(v,u))continue;const uvPath=shortestPath(u,v);if(void 0===uvPath)continue;let idealDistance="function"==typeof idealLength?uvPath*idealLength(u,v):uvPath*idealLength;const axis=(new optim_1.Vector).subVectors(v.center,u.center),actualDistance=axis.length()>0?u.shape.boundary(axis).distanceTo(v.shape.boundary(axis.negate())):0;if(storage.existsEdge(u,v,!0)&&actualDistance>idealDistance){const delta=actualDistance-idealDistance;yield gradients_1.nudgePair(u.center,v.center,[-wu*delta,-wv*delta])}else if(actualDistance<idealDistance){const delta=(idealDistance-actualDistance)/Math.pow(uvPath,2);yield gradients_1.nudgePair(u.center,v.center,[wu*delta,wv*delta])}}}}function*generateSpringElectricalForces(storage,idealLength,edgeStrength,repulsiveStrength){const visited=new Set;for(let u of storage.nodes()){visited.add(u);for(let v of storage.nodes()){if(visited.has(v))continue;if(u.fixed&&v.fixed)continue;const[wu,wv]=[u.fixed?0:1,v.fixed?0:1];if(storage.hasAncestor(u,v)||storage.hasAncestor(v,u))continue;"function"==typeof idealLength&&(idealLength=idealLength(u,v));const axis=(new optim_1.Vector).subVectors(v.center,u.center),actualDistance=axis.length()>0?u.shape.boundary(axis).distanceTo(v.shape.boundary(axis.negate())):1;if(storage.existsEdge(u,v,!0)){const delta=edgeStrength*(actualDistance-idealLength);yield gradients_1.nudgePair(u.center,v.center,[-wu*delta,-wv*delta])}else{const delta=repulsiveStrength*Math.pow(actualDistance,-1);yield gradients_1.nudgePair(u.center,v.center,[wu*delta,wv*delta])}}}}function*generateCompactnessForces(storage,strength){for(let u of storage.nodes())for(let child of u.children)yield gradients_1.nudgePair(u.center,child.center,-strength*u.center.distanceTo(child.center))}function*generateNodeChildrenConstraints(u,padding=0){let controlGrads=[],centerGrads=[],grads=[];u.children.map(child=>u.shape.constrainShapeWithin(child.shape,{offset:-padding,expansion:.2,masses:{shape:1,subshape:10}})).filter(grads=>grads.length>0).forEach(([shapeGrad,centerGrad,controlGrad])=>{controlGrads.push(controlGrad),centerGrads.push(centerGrad),grads.push(shapeGrad)});let controlGrad=void 0,centerGrad=void 0;controlGrads.forEach(grad=>{(!controlGrad||grad.grad.length()>controlGrad.grad.length())&&(controlGrad=grad)}),controlGrad&&grads.push(controlGrad),centerGrads.forEach(grad=>{(!centerGrad||grad.grad.length()>centerGrad.grad.length())&&(centerGrad=grad)}),centerGrad&&grads.push(centerGrad),yield grads,u.children.length>0&&(yield u.shape.constrainShapeCompact(u.children.map(child=>child.shape),-padding))}exports.generateSpringForces=generateSpringForces,exports.generateSpringElectricalForces=generateSpringElectricalForces,exports.generateCompactnessForces=generateCompactnessForces,exports.generateNodeChildrenConstraints=generateNodeChildrenConstraints;try{generateSpringForces.displayName="generateSpringForces",generateSpringForces.__docgenInfo={description:"Generates (1) attractive forces encouraging connected nodes to be no farther than their ideal\ndistance, and (2) repulsive forces between unconnected nodes encouraging them to be no closer\nthan their ideal distance. The ideal distance is the shortest path length scaled by the ideal\nlength. There are no forces generated between nodes of different connected components (with\nundefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a non-undefined `shortestPath`.\n@param shortestPath",displayName:"generateSpringForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/generators.ts#generateSpringForces"]={docgenInfo:generateSpringForces.__docgenInfo,name:"generateSpringForces",path:"src/graph/generators.ts#generateSpringForces"})}catch(__react_docgen_typescript_loader_error){}try{generateSpringElectricalForces.displayName="generateSpringElectricalForces",generateSpringElectricalForces.__docgenInfo={description:"Generates attractive forces encouraging edges to be no fthe ideal length and repulsive forces between\nunconnected nodes proportional to their shortest path length. There are no forces generated\nbetween forces from different connected components (with undefined shortest path length).\n@param storage\n@param idealLength Ideal length of an edge between nodes, either as a constant or function of the nodes. The\nfunction will only be called between nodes with a direct edge.\n@param shortestPath",displayName:"generateSpringElectricalForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/generators.ts#generateSpringElectricalForces"]={docgenInfo:generateSpringElectricalForces.__docgenInfo,name:"generateSpringElectricalForces",path:"src/graph/generators.ts#generateSpringElectricalForces"})}catch(__react_docgen_typescript_loader_error){}try{generateCompactnessForces.displayName="generateCompactnessForces",generateCompactnessForces.__docgenInfo={description:"Generates forces that pull children nodes towards the parent's center.\n@param storage\n@param strength",displayName:"generateCompactnessForces",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/generators.ts#generateCompactnessForces"]={docgenInfo:generateCompactnessForces.__docgenInfo,name:"generateCompactnessForces",path:"src/graph/generators.ts#generateCompactnessForces"})}catch(__react_docgen_typescript_loader_error){}try{generateNodeChildrenConstraints.displayName="generateNodeChildrenConstraints",generateNodeChildrenConstraints.__docgenInfo={description:"Constrain `u`'s children to be contained within itself, expansing its boundaries if necessary.\n@param u Node with children to constrain.\n@param padding Spacing inside the node's boundary.",displayName:"generateNodeChildrenConstraints",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/generators.ts#generateNodeChildrenConstraints"]={docgenInfo:generateNodeChildrenConstraints.__docgenInfo,name:"generateNodeChildrenConstraints",path:"src/graph/generators.ts#generateNodeChildrenConstraints"})}catch(__react_docgen_typescript_loader_error){}},781:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.kGraphTwo={nodes:[{id:"n0",shape:{type:"rectangle",width:20,height:20}},{id:"n1",shape:{type:"rectangle",width:20,height:20}}],edges:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}}]}},782:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(168),addon_knobs_1=__webpack_require__(204),src_1=__webpack_require__(328),Graph_1=__webpack_require__(330),schemas_simple_1=__webpack_require__(783),schemas_compound_1=__webpack_require__(784);react_2.storiesOf("force models",module).add("spring-electrical w/ simple nodes",()=>{const steps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",50),edgeStrength=addon_knobs_1.number("edge strength",1),repulsiveStrength=addon_knobs_1.number("repulsive strength",1),{nodes:nodes,edges:edges}=src_1.fromSchema(schemas_simple_1.kGraphSimple.nodes,schemas_simple_1.kGraphSimple.edges),storage=new src_1.StructuredStorage(nodes,edges),forceOptimizer=new src_1.EnergyOptimizer({lrInitial:.4,lrMax:.6,lrMin:.001}),constraintOptimizer=new src_1.BasicOptimizer(1),layout=new src_1.StagedLayout(storage,{steps:steps},{iterations:1,optimizer:forceOptimizer,generator:function*(storage){yield*src_1.generateSpringElectricalForces(storage,idealLength,edgeStrength,repulsiveStrength)}},{iterations:3,optimizer:constraintOptimizer,generator:function*(storage){for(let u of storage.nodes())yield*src_1.generateNodePortConstraints(u)}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("spring-electrical w/ compound nodes",()=>{const steps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",50),edgeStrength=addon_knobs_1.number("edge strength",1),repulsiveStrength=addon_knobs_1.number("repulsive strength",1),compactness=addon_knobs_1.number("children compactness",.5),{nodes:nodes,edges:edges}=src_1.fromSchema(schemas_compound_1.kGraphCompound.nodes,schemas_compound_1.kGraphCompound.edges),storage=new src_1.StructuredStorage(nodes,edges),forceOptimizer=new src_1.EnergyOptimizer({lrInitial:.4,lrMax:.6,lrMin:.001}),constraintOptimizer=new src_1.BasicOptimizer(1),nonoverlapScheduler=new src_1.BooleanScheduler(!0).for(20,!1),layout=new src_1.StagedLayout(storage,{steps:steps},{iterations:1,optimizer:forceOptimizer,generator:function*(storage){yield*src_1.generateSpringElectricalForces(storage,idealLength,edgeStrength,repulsiveStrength),yield*src_1.generateCompactnessForces(storage,compactness)}},{iterations:3,optimizer:constraintOptimizer,generator:function*(storage,step){for(let u of storage.nodes())if(yield*src_1.generateNodeChildrenConstraints(u),yield*src_1.generateNodePortConstraints(u),nonoverlapScheduler.get(step))for(let sibling of storage.siblings(u))yield src_1.constrainNodeNonoverlap(u,sibling)}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0,nodeColor:n=>n.meta&&n.meta.group||0})}).add("spring w/ simple nodes",()=>{const steps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",15),optimizerType=addon_knobs_1.select("optimizer",["EnergyOptimizer","RMSPropOptimizer","BasicOptimizer","TrustRegionOptimizer"],"EnergyOptimizer"),{nodes:nodes,edges:edges}=src_1.fromSchema(schemas_simple_1.kGraphSimple.nodes,schemas_simple_1.kGraphSimple.edges),storage=new src_1.StructuredStorage(nodes,edges),shortestPath=storage.shortestPaths();let forceOptimizer;switch(optimizerType){case"BasicOptimizer":forceOptimizer=new src_1.BasicOptimizer(.5,1);break;case"RMSPropOptimizer":forceOptimizer=new src_1.RMSPropOptimizer(2,.8);break;case"TrustRegionOptimizer":forceOptimizer=new src_1.TrustRegionOptimizer(1,.01,.9,10,.01);break;default:case"EnergyOptimizer":forceOptimizer=new src_1.EnergyOptimizer({lrInitial:.3,lrMax:.5,lrMin:.01,wait:20,decay:.9,growth:1.1,smoothing:.5})}const constraintOptimizer=new src_1.BasicOptimizer(1),layout=new src_1.StagedLayout(storage,{steps:steps},{iterations:1,optimizer:forceOptimizer,generator:function*(storage){yield*src_1.generateSpringForces(storage,idealLength,shortestPath)}},{iterations:3,optimizer:constraintOptimizer,generator:function*(storage){for(let u of storage.nodes())yield*src_1.generateNodePortConstraints(u)}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0})}).add("spring w/ compound nodes",()=>{const steps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",50),compactness=addon_knobs_1.number("children compactness",1),optimizerType=addon_knobs_1.select("optimizer",["EnergyOptimizer","RMSPropOptimizer","BasicOptimizer","TrustRegionOptimizer"],"EnergyOptimizer"),{nodes:nodes,edges:edges}=src_1.fromSchema(schemas_compound_1.kGraphCompound.nodes,schemas_compound_1.kGraphCompound.edges),storage=new src_1.StructuredStorage(nodes,edges),shortestPath=storage.shortestPaths();let forceOptimizer;switch(optimizerType){case"BasicOptimizer":forceOptimizer=new src_1.BasicOptimizer(.5,1);break;case"RMSPropOptimizer":forceOptimizer=new src_1.RMSPropOptimizer(2,.8);break;case"TrustRegionOptimizer":forceOptimizer=new src_1.TrustRegionOptimizer(1,.01,.9,10,.01);break;default:case"EnergyOptimizer":forceOptimizer=new src_1.EnergyOptimizer({lrInitial:.3,lrMax:.5,lrMin:.01,wait:20,decay:.9,growth:1.1,smoothing:.5})}const constraintOptimizer=new src_1.BasicOptimizer(1),nonoverlapScheduler=new src_1.BooleanScheduler(!0).for(20,!1),layout=new src_1.StagedLayout(storage,{steps:steps},{iterations:1,optimizer:forceOptimizer,generator:function*(storage){yield*src_1.generateSpringForces(storage,idealLength,shortestPath),yield*src_1.generateCompactnessForces(storage,compactness)}},{iterations:3,optimizer:constraintOptimizer,generator:function*(storage,step){for(let u of storage.nodes()){if(nonoverlapScheduler.get(step))for(let sibling of storage.siblings(u))yield src_1.constrainNodeNonoverlap(u,sibling);yield*src_1.generateNodeChildrenConstraints(u),yield*src_1.generateNodePortConstraints(u)}}});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,animated:!0,interactive:!0,nodeColor:n=>n.meta&&n.meta.group||0})})}).call(this,__webpack_require__(28)(module))},783:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphSimple={nodes:[],edges:[]};exports.kGraphSimple=kGraphSimple;for(let n=0;n<80;n++)kGraphSimple.nodes.push({id:`n${n}`,shape:{type:"rectangle",width:15,height:15}});[{t:1,s:0},{t:2,s:0},{t:9,s:0},{t:11,s:0},{t:78,s:1},{t:3,s:2},{t:4,s:3},{t:5,s:4},{t:6,s:5},{t:10,s:6},{t:8,s:7},{t:11,s:7},{t:12,s:8},{t:18,s:9},{t:35,s:10},{t:13,s:12},{t:14,s:12},{t:15,s:12},{t:16,s:12},{t:17,s:12},{t:19,s:12},{t:20,s:12},{t:21,s:12},{t:23,s:12},{t:25,s:12},{t:26,s:12},{t:28,s:12},{t:29,s:12},{t:31,s:12},{t:24,s:13},{t:45,s:14},{t:22,s:15},{t:49,s:16},{t:30,s:18},{t:39,s:19},{t:40,s:20},{t:50,s:21},{t:27,s:22},{t:63,s:23},{t:72,s:24},{t:60,s:26},{t:68,s:27},{t:59,s:29},{t:32,s:31},{t:33,s:31},{t:34,s:31},{t:36,s:31},{t:37,s:31},{t:38,s:31},{t:58,s:32},{t:75,s:33},{t:41,s:34},{t:48,s:35},{t:76,s:36},{t:42,s:37},{t:44,s:38},{t:46,s:38},{t:47,s:38},{t:43,s:39},{t:57,s:40},{t:67,s:41},{t:74,s:42},{t:51,s:43},{t:52,s:48},{t:53,s:48},{t:54,s:48},{t:55,s:48},{t:56,s:48},{t:61,s:48},{t:62,s:48},{t:64,s:62},{t:65,s:62},{t:66,s:62},{t:69,s:62},{t:70,s:69},{t:71,s:69},{t:73,s:69},{t:77,s:69},{t:79,s:78}].forEach(({s:s,t:t})=>{kGraphSimple.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})},784:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphCompound={nodes:[{id:"p0",children:[],meta:{group:0}},{id:"p1",children:[],meta:{group:1}},{id:"p2",children:[],meta:{group:2}},{id:"p3",children:[],meta:{group:3}},{id:"p4",children:[],meta:{group:4}},{id:"p5",children:[],meta:{group:5}},{id:"p6",children:[],meta:{group:6}},{id:"p7",children:[],meta:{group:7}},{id:"p8",children:[],meta:{group:8}},{id:"p9",children:[],meta:{group:9}},{id:"p10",children:[],meta:{group:10}}],edges:[]};exports.kGraphCompound=kGraphCompound;[1,1,1,1,1,1,1,1,1,1,2,2,3,2,2,2,3,3,3,3,3,3,3,3,4,4,5,4,0,2,3,2,2,2,2,2,2,2,2,4,6,4,4,5,0,0,7,7,8,5,5,5,5,5,5,8,5,8,8,8,8,8,8,8,8,8,8,9,4,4,4,4,5,10,10,4,8].forEach((parent,child)=>{kGraphCompound.nodes.push({id:`n${child}`,shape:{type:"rectangle",width:15,height:15},meta:{group:parent}}),kGraphCompound.nodes[parent].children.push(`n${child}`)}),[{s:1,t:0},{s:2,t:0},{s:3,t:0},{s:3,t:2},{s:4,t:0},{s:5,t:0},{s:6,t:0},{s:7,t:0},{s:8,t:0},{s:9,t:0},{s:11,t:10},{s:11,t:3},{s:11,t:2},{s:11,t:0},{s:12,t:11},{s:13,t:11},{s:14,t:11},{s:15,t:11},{s:17,t:16},{s:18,t:16},{s:18,t:17},{s:19,t:16},{s:19,t:17},{s:19,t:18},{s:20,t:16},{s:20,t:17},{s:20,t:18},{s:20,t:19},{s:21,t:16},{s:21,t:17},{s:21,t:18},{s:21,t:19},{s:21,t:20},{s:22,t:16},{s:22,t:17},{s:22,t:18},{s:22,t:19},{s:22,t:20},{s:22,t:21},{s:23,t:16},{s:23,t:17},{s:23,t:18},{s:23,t:19},{s:23,t:20},{s:23,t:21},{s:23,t:22},{s:23,t:12},{s:23,t:11},{s:24,t:23},{s:24,t:11},{s:25,t:24},{s:25,t:23},{s:25,t:11},{s:26,t:24},{s:26,t:11},{s:26,t:16},{s:26,t:25},{s:27,t:11},{s:27,t:23},{s:27,t:25},{s:27,t:24},{s:27,t:26},{s:28,t:11},{s:28,t:27},{s:29,t:23},{s:29,t:27},{s:29,t:11},{s:30,t:23},{s:31,t:30},{s:31,t:11},{s:31,t:23},{s:31,t:27},{s:32,t:11},{s:33,t:11},{s:33,t:27},{s:34,t:11},{s:34,t:29},{s:35,t:11},{s:35,t:34},{s:35,t:29},{s:36,t:34},{s:36,t:35},{s:36,t:11},{s:36,t:29},{s:37,t:34},{s:37,t:35},{s:37,t:36},{s:37,t:11},{s:37,t:29},{s:38,t:34},{s:38,t:35},{s:38,t:36},{s:38,t:37},{s:38,t:11},{s:38,t:29},{s:39,t:25},{s:40,t:25},{s:41,t:24},{s:41,t:25},{s:42,t:41},{s:42,t:25},{s:42,t:24},{s:43,t:11},{s:43,t:26},{s:43,t:27},{s:44,t:28},{s:44,t:11},{s:45,t:28},{s:47,t:46},{s:48,t:47},{s:48,t:25},{s:48,t:27},{s:48,t:11},{s:49,t:26},{s:49,t:11},{s:50,t:49},{s:50,t:24},{s:51,t:49},{s:51,t:26},{s:51,t:11},{s:52,t:51},{s:52,t:39},{s:53,t:51},{s:54,t:51},{s:54,t:49},{s:54,t:26},{s:55,t:51},{s:55,t:49},{s:55,t:39},{s:55,t:54},{s:55,t:26},{s:55,t:11},{s:55,t:16},{s:55,t:25},{s:55,t:41},{s:55,t:48},{s:56,t:49},{s:56,t:55},{s:57,t:55},{s:57,t:41},{s:57,t:48},{s:58,t:55},{s:58,t:48},{s:58,t:27},{s:58,t:57},{s:58,t:11},{s:59,t:58},{s:59,t:55},{s:59,t:48},{s:59,t:57},{s:60,t:48},{s:60,t:58},{s:60,t:59},{s:61,t:48},{s:61,t:58},{s:61,t:60},{s:61,t:59},{s:61,t:57},{s:61,t:55},{s:62,t:55},{s:62,t:58},{s:62,t:59},{s:62,t:48},{s:62,t:57},{s:62,t:41},{s:62,t:61},{s:62,t:60},{s:63,t:59},{s:63,t:48},{s:63,t:62},{s:63,t:57},{s:63,t:58},{s:63,t:61},{s:63,t:60},{s:63,t:55},{s:64,t:55},{s:64,t:62},{s:64,t:48},{s:64,t:63},{s:64,t:58},{s:64,t:61},{s:64,t:60},{s:64,t:59},{s:64,t:57},{s:64,t:11},{s:65,t:63},{s:65,t:64},{s:65,t:48},{s:65,t:62},{s:65,t:58},{s:65,t:61},{s:65,t:60},{s:65,t:59},{s:65,t:57},{s:65,t:55},{s:66,t:64},{s:66,t:58},{s:66,t:59},{s:66,t:62},{s:66,t:65},{s:66,t:48},{s:66,t:63},{s:66,t:61},{s:66,t:60},{s:67,t:57},{s:68,t:25},{s:68,t:11},{s:68,t:24},{s:68,t:27},{s:68,t:48},{s:68,t:41},{s:69,t:25},{s:69,t:68},{s:69,t:11},{s:69,t:24},{s:69,t:27},{s:69,t:48},{s:69,t:41},{s:70,t:25},{s:70,t:69},{s:70,t:68},{s:70,t:11},{s:70,t:24},{s:70,t:27},{s:70,t:41},{s:70,t:58},{s:71,t:27},{s:71,t:69},{s:71,t:68},{s:71,t:70},{s:71,t:11},{s:71,t:48},{s:71,t:41},{s:71,t:25},{s:72,t:26},{s:72,t:27},{s:72,t:11},{s:73,t:48},{s:74,t:48},{s:74,t:73},{s:75,t:69},{s:75,t:68},{s:75,t:25},{s:75,t:48},{s:75,t:41},{s:75,t:70},{s:75,t:71},{s:76,t:64},{s:76,t:65},{s:76,t:66},{s:76,t:63},{s:76,t:62},{s:76,t:48},{s:76,t:58}].forEach(({s:s,t:t})=>{kGraphCompound.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})},86:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(761)),__export(__webpack_require__(762));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{NumberScheduler.displayName="NumberScheduler",NumberScheduler.__docgenInfo={description:"A `NumberScheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"NumberScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#NumberScheduler"]={docgenInfo:NumberScheduler.__docgenInfo,name:"NumberScheduler",path:"src/optim/index.ts#NumberScheduler"})}catch(__react_docgen_typescript_loader_error){}try{BooleanScheduler.displayName="BooleanScheduler",BooleanScheduler.__docgenInfo={description:"A `BooleanScheduler` returns some boolean value that changes over time according to a sequence of\nactive ranges.",displayName:"BooleanScheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#BooleanScheduler"]={docgenInfo:BooleanScheduler.__docgenInfo,name:"BooleanScheduler",path:"src/optim/index.ts#BooleanScheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{ScheduledOptimizer.displayName="ScheduledOptimizer",ScheduledOptimizer.__docgenInfo={description:"A `ScheduledOptimizer` uses a variable learning rate set by a `Scheduler`.",displayName:"ScheduledOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#ScheduledOptimizer"]={docgenInfo:ScheduledOptimizer.__docgenInfo,name:"ScheduledOptimizer",path:"src/optim/index.ts#ScheduledOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{EnergyOptimizer.displayName="EnergyOptimizer",EnergyOptimizer.__docgenInfo={description:"A `EnergyOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before). The energy function\nis the squared norm of all the gradients between successive `update()` calls.",displayName:"EnergyOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#EnergyOptimizer"]={docgenInfo:EnergyOptimizer.__docgenInfo,name:"EnergyOptimizer",path:"src/optim/index.ts#EnergyOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{RMSPropOptimizer.displayName="RMSPropOptimizer",RMSPropOptimizer.__docgenInfo={description:"A `RMSPropOptimizer` uses an adaptive scheme based on a per-parameter moving weighted average of\nmagnitudes.",displayName:"RMSPropOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#RMSPropOptimizer"]={docgenInfo:RMSPropOptimizer.__docgenInfo,name:"RMSPropOptimizer",path:"src/optim/index.ts#RMSPropOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme that increasing the learning rate if the\ngradients are growing, and decreasing the learning rate if the gradients are shrinking.",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}}},[[338,1,2]]]);
//# sourceMappingURL=main.f73f42c7836837ac5317.bundle.js.map