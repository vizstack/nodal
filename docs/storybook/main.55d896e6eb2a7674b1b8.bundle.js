(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{147:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(760)),__export(__webpack_require__(761));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/optim/index.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}},206:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(147)),__export(__webpack_require__(762));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/index.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. Note that because many rendering schemes make the\npositive-y axis point downwards, the angle is measured clockwise from 0 (not counter-clockwise\nas is the convention in trigonometry).\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle A single angle or list of angles, in degrees within range [0, 360].\n@param strength Maximum magnitude restoring force, when vector is directly opposite the angle.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/index.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - control | ^ power` and\ndirections pointing away from each other (when `f` is positive) or towards each other (when\n`f` is negative), for `f = scalar * ( || u - v || - control )`. It is possible to specify a pair\nof different `scalar` values to apply to each node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/index.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/index.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/index.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/index.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},207:function(module,exports,__webpack_require__){"use strict";var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)Object.hasOwnProperty.call(mod,k)&&(result[k]=mod[k]);return result.default=mod,result};Object.defineProperty(exports,"__esModule",{value:!0});const React=__importStar(__webpack_require__(0)),kPortRadius=2,kAnimationTick=0,kLayoutSteps=250;class Graph extends React.Component{constructor(props){super(props),this.onMouseDown=(node,x,y)=>{if(!this.props.interactive)return;void 0!==this.state.drag&&this.onMouseUp();const fixed=node.fixed;this.setState(state=>({drag:{node:node,origin:{x:x,y:y},center:{x:node.center.x,y:node.center.y},fixed:fixed,bounds:state.bounds}})),node.fixed=!0,this.doLayout(kLayoutSteps)},this.onMouseUp=()=>{if(this.props.interactive&&void 0!==this.state.drag){const{storage:storage}=this.props,{node:node,fixed:fixed}=this.state.drag;node.fixed=fixed,this.setState({drag:void 0}),this.setState({nodes:storage.nodes(),edges:storage.edges(),bounds:storage.bounds()})}},this.onMouseMove=(x,y)=>{if(this.props.interactive&&void 0!==this.state.drag){const{node:node,origin:origin,center:center}=this.state.drag;node.center.set(x-origin.x+center.x,y-origin.y+center.y),this.forceUpdate()}};const{layout:layout,storage:storage,animated:animated}=this.props;this.state={nodes:storage.nodes(),edges:storage.edges(),bounds:storage.bounds(),drag:void 0},animated&&layout.onStep(elems=>(this.setState({nodes:elems.nodes(),edges:elems.edges(),bounds:elems.bounds()}),setTimeout(()=>layout.start(),kAnimationTick),!1)),layout.onEnd(elems=>{this.setState({nodes:elems.nodes(),edges:elems.edges(),bounds:elems.bounds()})})}componentDidMount(){const{layout:layout}=this.props;console.warn("MOUNTED"),layout.start()}doLayout(steps){steps<=0||setTimeout(()=>{this.props.layout.step(),this.forceUpdate(),this.doLayout(steps-1)},0)}render(){const{nodes:nodes=[],edges:edges=[],drag:drag}=this.state,bounds=drag?drag.bounds:this.state.bounds,{size:size=[0,0]}=this.props,nodeColor=n=>{if(!this.props.nodeColor)return Palette[0];const value=this.props.nodeColor(n);return"number"==typeof value?Palette[value%Palette.length]:value},edgeColor=e=>{if(!this.props.edgeColor)return Palette[13];const value=this.props.edgeColor(e);return"number"==typeof value?Palette[value%Palette.length]:value},compoundNodeComponents=[];for(let node of nodes)node.children.length>0&&compoundNodeComponents.push(React.createElement("g",{key:node.id,id:node.id},React.createElement("rect",{x:node.center.x-node.shape.width/2,y:node.center.y-node.shape.height/2,width:node.shape.width,height:node.shape.height,fill:nodeColor(node),stroke:Color.white,strokeWidth:1.5,rx:4,opacity:.3}),React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontWeight:"bold",fontSize:"10",fill:nodeColor(node),opacity:1,pointerEvents:"none",userSelect:"none"}},node.id.substring(1)),Object.entries(node.ports).map(([name,port])=>name.startsWith("_")?null:React.createElement("circle",{cx:port.point.x,cy:port.point.y,r:kPortRadius,fill:nodeColor(node),stroke:Color.white,strokeWidth:.75}))));const simpleNodeComponents=[];for(let node of nodes)0==node.children.length&&simpleNodeComponents.push(React.createElement("g",{key:node.id,id:node.id},React.createElement("rect",{x:node.center.x-node.shape.width/2,y:node.center.y-node.shape.height/2,width:node.shape.width,height:node.shape.height,fill:nodeColor(node),stroke:Color.white,strokeWidth:1,rx:4,onMouseDown:e=>this.onMouseDown(node,e.clientX,e.clientY)}),React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontSize:"10",fill:Color.white,opacity:.75,pointerEvents:"none",userSelect:"none"}},node.id.substring(1)),Object.entries(node.ports).map(([name,port])=>name.startsWith("_")?null:React.createElement("circle",{cx:port.point.x,cy:port.point.y,r:kPortRadius,fill:nodeColor(node),stroke:Color.white,strokeWidth:.75}))));const edgeComponents=[];for(let edge of edges)edgeComponents.push(React.createElement("g",{key:edge.id,id:edge.id},React.createElement("path",{d:"M "+edge.path.map(({x:x,y:y})=>`${x} ${y}`).join(" L "),style:{fill:"none",stroke:edgeColor(edge),strokeWidth:2,opacity:.75}})));return React.createElement("svg",{viewBox:bounds?`${bounds.x} ${bounds.y} ${Math.max(bounds.width,size[0])} ${Math.max(bounds.height,size[1])}`:void 0,width:bounds?`${Math.max(bounds.width,size[0])}`:"100%",height:bounds?`${Math.max(bounds.height,size[1])}`:"100%",onMouseMove:e=>this.onMouseMove(e.clientX,e.clientY),onMouseUp:e=>this.onMouseUp()},edgeComponents,compoundNodeComponents,simpleNodeComponents)}}exports.Graph=Graph,Graph.defaultProps={animated:!1,interactive:!1,size:[500,500]};const Color={white:"#FFFFFF",black:"#000000",gray:{l2:"#F1F3F5",l1:"#E9ECEE",base:"#DEE2E6",d1:"#B8C4CF",d2:"#8895A7"},blue:{l2:"#EFF8FF",l1:"#AAD4F6",base:"#3183C8",d1:"#2368A2",d2:"#194971"},teal:{l2:"#E7FFFE",l1:"#A8EEEC",base:"#3CAEA3",d1:"#2A9187",d2:"#1B655E"},green:{l2:"#E3FCEC",l1:"#A8EEC1",base:"#38C172",d1:"#249D57",d2:"#187741"},yellow:{l2:"#FFFCF4",l1:"#FDF3D7",base:"#F4CA64",d1:"#CAA53D",d2:"#8C6D1F"},red:{l2:"#FCE8E8",l1:"#F4AAAA",base:"#DC3030",d1:"#B82020",d2:"#881B1B"}},Palette=["#4E79A7","#A0CBE8","#F28E2B","#FFBE7D","#59A14F","#8CD17D","#B6992D","#F1CE63","#499894","#86BCB6","#E15759","#FF9D9A","#79706E","#BAB0AC","#D37295","#FABFD2","#B07AA1","#D4A6C8","#9D7660","#D7B5A6"];try{Graph.displayName="Graph",Graph.__docgenInfo={description:"",displayName:"Graph",props:{storage:{defaultValue:null,description:"",name:"storage",required:!0,type:{name:"Storage"}},layout:{defaultValue:null,description:"",name:"layout",required:!0,type:{name:"ForceConstraintLayout"}},animated:{defaultValue:{value:"false"},description:"Whether to run animation during layout process.",name:"animated",required:!1,type:{name:"boolean"}},interactive:{defaultValue:{value:"false"},description:"Whether to allow mouse interaction.",name:"interactive",required:!1,type:{name:"boolean"}},nodeColor:{defaultValue:null,description:"Function to specify color, as a string or an index into the default color palette.",name:"nodeColor",required:!1,type:{name:"(n: Node) => ReactText"}},edgeColor:{defaultValue:null,description:"",name:"edgeColor",required:!1,type:{name:"(e: Edge) => ReactText"}},size:{defaultValue:null,description:"Minimum graph size.",name:"size",required:!1,type:{name:"[number, number]"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["stories/Graph.tsx#Graph"]={docgenInfo:Graph.__docgenInfo,name:"Graph",path:"stories/Graph.tsx#Graph"})}catch(__react_docgen_typescript_loader_error){}},337:function(module,exports,__webpack_require__){__webpack_require__(338),__webpack_require__(449),module.exports=__webpack_require__(450)},360:function(module,exports){},450:function(module,exports,__webpack_require__){"use strict";(function(module){Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__webpack_require__(127),addon_info_1=__webpack_require__(601),addon_knobs_1=__webpack_require__(204);react_1.addDecorator(addon_info_1.withInfo),react_1.addDecorator(addon_knobs_1.withKnobs);const req=__webpack_require__(757);react_1.configure(function loadStories(){req.keys().sort().forEach(req)},module)}).call(this,__webpack_require__(27)(module))},604:function(module,exports,__webpack_require__){var map={"./nestedObjectAssign":292,"./nestedObjectAssign.js":292};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=604},757:function(module,exports,__webpack_require__){var map={"./features.stories.tsx":758,"./force-models.stories.tsx":779,"./rendering.stories.tsx":782};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=757},758:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(127),addon_knobs_1=__webpack_require__(204),schemas_five_1=__webpack_require__(759),src_1=__webpack_require__(206),Graph_1=__webpack_require__(207),schemas_two_1=__webpack_require__(778);function*forceSpringModel(elems,shortestPath,idealLength,compactness){const visited=new Set;for(let u of elems.nodes()){if(visited.add(u),u.children.length>0)for(let child of u.children)yield src_1.forcePairwiseNodes(u,child,-compactness*u.center.distanceTo(child.center));for(let v of elems.nodes()){if(visited.has(v))continue;const[wu,wv]=[1,1],uvPath=shortestPath(u,v);if(void 0===uvPath)continue;const idealDistance=idealLength*uvPath,actualDistance=u.center.distanceTo(v.center);if(elems.existsEdge(u,v,!0)&&actualDistance>idealLength){const delta=actualDistance-idealLength;yield src_1.forcePairwiseNodes(u,v,[-wu*delta,-wv*delta])}else if(actualDistance<idealDistance){const delta=idealDistance-actualDistance;yield src_1.forcePairwiseNodes(u,v,[wu*delta,wv*delta])}}}}function*constrainNodes(elems,step){for(let u of elems.nodes()){if(step>15)for(let sibling of elems.siblings(u))yield src_1.positionNoOverlap(u,sibling);yield src_1.positionChildren(u),yield src_1.positionPorts(u)}}const configForceElectrical={numSteps:200,numConstraintIters:5,numForceIters:5,forceOptimizer:new src_1.TrustRegionOptimizer({lrInitial:.8,lrMax:.8,lrMin:.001,adaption:.99})};react_2.storiesOf("features",module).add("simple nodes",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesEqual,schemas_five_1.kGraphFive.edgesAcyclic),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){yield*constrainNodes(elems,step)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("simple nodes (unequal)",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesAcyclic),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){yield*constrainNodes(elems,step)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("disconnected components",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesUnequal,[]),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){yield*constrainNodes(elems,step)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("compound nodes",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesNested,schemas_five_1.kGraphFive.edgesAcyclic),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),compactness=addon_knobs_1.number("group compactness",.5),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,compactness)},function*(elems,step){yield*constrainNodes(elems,step)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("unidirectional flow",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesEqual,schemas_five_1.kGraphFive.edgesAcyclic),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){if(yield*constrainNodes(elems,step),step>10)for(let e of elems.edges())yield src_1.constrainOffset(e.source.node.center,e.target.node.center,">=",50,[0,1],{masses:[e.source.node.fixed?1e9:1,e.target.node.fixed?1e9:1]})},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("multidirectional flow",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){function constrain(uid,vid,direction){const u=elems.node(uid),v=elems.node(vid);return src_1.constrainOffset(u.center,v.center,">=",50,direction,{masses:[u.fixed?1e9:1,v.fixed?1e9:1]})}yield*constrainNodes(elems,step),yield constrain("n0","n1",[1,0]),yield constrain("n1","n2",[0,1]),yield constrain("n2","n3",[1,0]),yield constrain("n2","n4",[0,1])},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("named ports",()=>{console.log("named ports");const nodesUnequalWithPorts=schemas_five_1.kGraphFive.nodesUnequal.map(n=>Object.assign({ports:{e1:{location:"east",order:1},e2:{location:"east",order:2},w1:{location:"west",order:1},w2:{location:"west",order:2},n1:{location:"north",order:1},n2:{location:"north",order:2},s1:{location:"south",order:1},s2:{location:"south",order:2}}},n)),[nodes,edges]=src_1.fromSchema(nodesUnequalWithPorts,[{id:"e0->1",source:{id:"n0",port:"e1"},target:{id:"n1",port:"w1"}},{id:"e1->2:1",source:{id:"n1",port:"s1"},target:{id:"n2",port:"n1"}},{id:"e1->2:2",source:{id:"n1",port:"s2"},target:{id:"n2",port:"n2"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}},{id:"e2->4",source:{id:"n2"},target:{id:"n4"}}]),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){function constrain(uid,vid,direction){const u=elems.node(uid),v=elems.node(vid);return src_1.constrainOffset(u.center,v.center,">=",50,direction,{masses:[u.fixed?1e9:1,v.fixed?1e9:1]})}yield*constrainNodes(elems,step),yield constrain("n0","n1",[1,0]),yield constrain("n1","n2",[0,1]),yield constrain("n2","n3",[1,0]),yield constrain("n2","n4",[0,1])},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("oriented edges",()=>{const[nodes,edges]=src_1.fromSchema(schemas_two_1.kGraphTwo.nodes,schemas_two_1.kGraphTwo.edges),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",100),orientationAngle=addon_knobs_1.number("orientation angle",45,{range:!0,min:0,max:360,step:1}),orientationStrength=addon_knobs_1.number("orientation strength",10),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0);for(let edge of elems.edges())yield src_1.constrainAngle(edge.source.node.center,edge.target.node.center,orientationAngle,orientationStrength)},function*(elems,step){yield*constrainNodes(elems,step)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("alignment",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesTree),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){function align(u,v,axis){return src_1.positionAlignment([elems.node(u),elems.node(v)],axis)}yield*constrainNodes(elems,step),yield align("n0","n1",[1,0]),yield align("n1","n2",[0,1]),yield align("n2","n3",[1,0]),yield align("n2","n4",[0,1])},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("grid snap",()=>{const[nodes,edges]=src_1.fromSchema(schemas_five_1.kGraphFive.nodesUnequal,schemas_five_1.kGraphFive.edgesAcyclic),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),gridSnap=addon_knobs_1.boolean("grid snap",!0),gridX=addon_knobs_1.number("grid x",5),gridY=addon_knobs_1.number("grid y",10),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){if(yield*constrainNodes(elems,step),gridSnap&&step>100)for(let u of elems.nodes())yield src_1.positionGridSnap(u,gridX,gridY)},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("limp noodle",()=>{const fire=idx=>({nodes:[{id:`n${idx}:group`,children:[`n${idx}:conv1`,`n${idx}:relu1`,`n${idx}:conv21`,`n${idx}:conv22`,`n${idx}:relu21`,`n${idx}:relu22`,`n${idx}:cat`]},{id:`n${idx}:conv1`,shape:{width:50,height:21}},{id:`n${idx}:relu1`,shape:{width:36,height:21}},{id:`n${idx}:conv21`,shape:{width:50,height:21}},{id:`n${idx}:conv22`,shape:{width:50,height:21}},{id:`n${idx}:relu21`,shape:{width:36,height:21}},{id:`n${idx}:relu22`,shape:{width:36,height:21}},{id:`n${idx}:cat`,shape:{width:71,height:21}}],edges:[{id:`${idx}:c1r1`,source:{id:`n${idx}:conv1`},target:{id:`n${idx}:relu1`}},{id:`${idx}:r1c21`,source:{id:`n${idx}:relu1`},target:{id:`n${idx}:conv21`}},{id:`${idx}:r1c22`,source:{id:`n${idx}:relu1`},target:{id:`n${idx}:conv22`}},{id:`${idx}:c21r21`,source:{id:`n${idx}:conv21`},target:{id:`n${idx}:relu21`}},{id:`${idx}:c22r22`,source:{id:`n${idx}:conv22`},target:{id:`n${idx}:relu22`}},{id:`${idx}:r21cat`,source:{id:`n${idx}:relu21`},target:{id:`n${idx}:cat`}},{id:`${idx}:r22cat`,source:{id:`n${idx}:relu22`},target:{id:`n${idx}:cat`}}]}),nodeSchemas=[...fire(0).nodes,...fire(1).nodes,...fire(2).nodes,...fire(3).nodes],edgeSchemas=[...fire(0).edges,...fire(1).edges,...fire(2).edges,...fire(3).edges];edgeSchemas.push({id:"0:cat1:1conv1",source:{id:"n0:cat"},target:{id:"n1:conv1"}}),edgeSchemas.push({id:"1:cat1:2conv1",source:{id:"n1:cat"},target:{id:"n2:conv1"}}),edgeSchemas.push({id:"2:cat1:3conv1",source:{id:"n2:cat"},target:{id:"n3:conv1"}});const[nodes,edges]=src_1.fromSchema(nodeSchemas,edgeSchemas),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),idealLength=addon_knobs_1.number("ideal length",30),flowSpacing=addon_knobs_1.number("flow spacing",30),layout=new src_1.ForceConstraintLayout(elems,function*(elems){yield*forceSpringModel(elems,shortestPath,idealLength,0)},function*(elems,step){if(yield*constrainNodes(elems,step),console.log("foo"),step>0)for(let{source:source,target:target}of elems.edges()){const offset=(source.node.shape.height+target.node.shape.height)/2,portLocations=["south","north"],flowAxis=[0,1];yield src_1.constrainOffset(source.node.center,target.node.center,">=",flowSpacing+offset,flowAxis),source.node.ports[source.port].location=portLocations[0],target.node.ports[target.port].location=portLocations[1]}},configForceElectrical);return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})})}).call(this,__webpack_require__(27)(module))},759:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.kGraphFive={nodesEqual:[{id:"n0",shape:{width:20,height:20}},{id:"n1",shape:{width:20,height:20}},{id:"n2",shape:{width:20,height:20}},{id:"n3",shape:{width:20,height:20}},{id:"n4",shape:{width:20,height:20}}],nodesUnequal:[{id:"n0",shape:{width:20,height:20}},{id:"n1",shape:{width:40,height:20}},{id:"n2",shape:{width:40,height:40}},{id:"n3",shape:{width:20,height:40}},{id:"n4",shape:{width:20,height:20}}],nodesNested:[{id:"n0",shape:{width:20,height:20}},{id:"n1",shape:{width:20,height:20},children:["n2","n3"]},{id:"n2",shape:{width:20,height:20}},{id:"n3",shape:{width:20,height:20}},{id:"n4",shape:{width:20,height:20}}],edgesAcyclic:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e0->2",source:{id:"n0"},target:{id:"n2"}},{id:"e0->3",source:{id:"n0"},target:{id:"n3"}},{id:"e0->4",source:{id:"n0"},target:{id:"n4"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}}],edgesCyclic:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e1->2",source:{id:"n1"},target:{id:"n2"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}},{id:"e3->0",source:{id:"n3"},target:{id:"n0"}},{id:"e3->4",source:{id:"n3"},target:{id:"n4"}}],edgesTree:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}},{id:"e1->2",source:{id:"n1"},target:{id:"n2"}},{id:"e2->3",source:{id:"n2"},target:{id:"n3"}},{id:"e2->4",source:{id:"n2"},target:{id:"n4"}}]}},760:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Scheduler{constructor(defaultValue=0){this._interpolators=[],this._end=0,this._defaultValue=defaultValue}to(t,fn){if(t<=this._end)throw Error(`Already set in range [0, ${this._end}); got t = ${t}`);return this._interpolators.push([this._end,t,fn]),this._end=t,this}for(deltat,fn){if(deltat<1)throw Error(`New range must be positive; got deltat = ${deltat}`);return this._interpolators.push([this._end,this._end+deltat,fn]),this._end+=deltat,this}get(t){if(t<0||this._end<=t)return this._defaultValue;for(const[start,end,fn]of this._interpolators)if(start<=t&&t<end)return fn((t-start)/(end-start));return this._defaultValue}}function constant(value){return u=>value}function linear(start,end){return u=>(end-start)*u+start}function exponential(start,end,curvature=1){return Math.abs(curvature)<.1?linear(start,end):start<=end?u=>(Math.pow(2,curvature*u)-1)/(Math.pow(2,curvature)-1)*(end-start)+start:u=>(Math.pow(2,curvature*(1-u))-1)/(Math.pow(2,curvature)-1)*(start-end)+end}exports.Scheduler=Scheduler,exports.constant=constant,exports.linear=linear,exports.exponential=exponential;try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/scheduler.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/scheduler.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/scheduler.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/optim/scheduler.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}},761:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(329);class Vector extends three_1.Vector2{}exports.Vector=Vector;class Gradient{constructor(point,grad){this.point=point,this.grad=grad}}exports.Gradient=Gradient;class Optimizer{}exports.Optimizer=Optimizer;class BasicOptimizer extends Optimizer{constructor(lr=1,decay=1){super(),this.lr=lr,this.decay=decay}step(gradients){gradients.forEach(grad=>grad.point.add(grad.grad.clone().multiplyScalar(this.lr)))}update(){this.lr=Math.max(this.lr*this.decay,.01)}}exports.BasicOptimizer=BasicOptimizer;class TrustRegionOptimizer extends Optimizer{constructor(config={}){super(),this._numStepsImproved=0,this._prevEnergy=Number.MAX_VALUE,this._currEnergy=0;const{lrInitial:lrInitial=1,adaption:adaption=.9,wait:wait=5,lrMax:lrMax=1,lrMin:lrMin=.01}=config;if(adaption>1)throw Error("Must specify value of `adaption` <= 1");if(wait<0)throw Error("Must specify value of `wait` >= 0");this._config={lrInitial:lrInitial,adaption:adaption,wait:wait,lrMax:lrMax,lrMin:lrMin},this._lr=lrInitial}step(gradients){let energy=0;gradients.forEach(grad=>{grad.point.add(grad.grad.clone().multiplyScalar(this._lr)),energy+=grad.grad.length()}),energy/=gradients.length+1,this._currEnergy+=energy}update(){this._currEnergy<this._prevEnergy?(this._numStepsImproved+=1,this._numStepsImproved>=this._config.wait&&(this._numStepsImproved=0,this._lr/=this._config.adaption)):(this._numStepsImproved=0,this._lr*=this._config.adaption),this._lr=Math.max(this._lr,this._config.lrMin),this._lr=Math.min(this._lr,this._config.lrMax),this._prevEnergy=this._currEnergy,this._currEnergy=0}}exports.TrustRegionOptimizer=TrustRegionOptimizer;try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/optimizer.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/optimizer.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/optimizer.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate and decay factor.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/optimizer.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/optimizer.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}},762:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(763)),__export(__webpack_require__(774)),__export(__webpack_require__(775)),__export(__webpack_require__(777));try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. Note that because many rendering schemes make the\npositive-y axis point downwards, the angle is measured clockwise from 0 (not counter-clockwise\nas is the convention in trigonometry).\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle A single angle or list of angles, in degrees within range [0, 360].\n@param strength Maximum magnitude restoring force, when vector is directly opposite the angle.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/graph/index.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - control | ^ power` and\ndirections pointing away from each other (when `f` is positive) or towards each other (when\n`f` is negative), for `f = scalar * ( || u - v || - control )`. It is possible to specify a pair\nof different `scalar` values to apply to each node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/graph/index.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/graph/index.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/graph/index.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/graph/index.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},763:function(module,exports,__webpack_require__){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(147),lodash_1=__webpack_require__(764),seedrandom_1=__importDefault(__webpack_require__(765)),kPortOffset=.2;function fromSchema(nodeSchemas,edgeSchemas){const nodeIdToIdx=new Map,nodes=nodeSchemas.map(({id:id,center:center,shape:shape,fixed:fixed,children:children,ports:ports,meta:meta},idx)=>{if(!id)throw Error(`Invalid NodeId: ${id}`);if(nodeIdToIdx.has(id))throw Error(`Duplicate NodeId: ${id}`);nodeIdToIdx.set(id,idx);const rand=seedrandom_1.default(id),centerpt=center?new optim_1.Vector(center.x,center.y):new optim_1.Vector(rand(),rand());return{id:id,center:centerpt,shape:shape||{width:0,height:0},fixed:fixed||!1,children:children||[],ports:ports?lodash_1.mapValues(ports,({location:location,order:order,point:point})=>({location:location,order:order,point:point?new optim_1.Vector(point.x,point.y):new optim_1.Vector(centerpt.x+kPortOffset*rand(),centerpt.y+kPortOffset*rand())})):{},meta:meta}});function processEndpoint(edgeId,type,nodeId,port){const idx=nodeIdToIdx.get(nodeId);if(void 0===idx)throw Error(`Invalid ${type} NodeId: ${nodeId}, edge ${edgeId}`);const node=nodes[idx];let point;if(port){if(!(port in node.ports))throw Error(`Invalid ${type} port name: ${port}, ${type} ${nodeId}, edge ${edgeId}`);point=node.ports[port].point}else{const rand=seedrandom_1.default(`${edgeId}-${type}`);port=`_${edgeId}`,point=new optim_1.Vector(node.center.x+kPortOffset*rand(),node.center.y+kPortOffset*rand()),node.ports[port]={point:point}}return{id:nodeId,port:port,node:node,point:point}}nodes.forEach(node=>node.children=node.children.map(id=>{const childIdx=nodeIdToIdx.get(id);if(void 0===childIdx)throw Error(`Invalid child NodeId: ${id}, parent ${node.id}`);return nodes[childIdx]}));const edgeIdToIdx=new Set,edges=edgeSchemas.map(({id:id,source:source,target:target,path:path,meta:meta})=>{if(!id)throw Error(`Invalid EdgeId: ${id}`);if(edgeIdToIdx.has(id))throw Error(`Duplicate EdgeId: ${id}`);edgeIdToIdx.add(id);const s=processEndpoint(id,"source",source.id,source.port),t=processEndpoint(id,"target",target.id,target.port);return{id:id,source:s,target:t,path:path?path.map(({x:x,y:y})=>new optim_1.Vector(x,y)):[s.point,t.point],meta:meta}});return[nodes,edges]}exports.fromSchema=fromSchema,exports.toSchema=function toSchema(nodes,edges){return[nodes.map(node=>({id:node.id,center:{x:node.center.x,y:node.center.y},shape:node.shape,fixed:node.fixed,children:node.children.map(child=>child.id),ports:Object.fromEntries(Object.entries(node.ports).map(([name,{location:location,order:order,point:point}])=>[name,{location:location,order:order,point:{x:point.x,y:point.y}}])),meta:node.meta})),edges.map(edge=>({id:edge.id,source:{id:edge.source.id,port:edge.source.port},target:{id:edge.target.id,port:edge.target.port},path:edge.path.map(point=>({x:point.x,y:point.y})),meta:edge.meta}))]};try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/elements.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/elements.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}},773:function(module,exports){},774:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(329),optim_1=__webpack_require__(147),kZeroThreshold=.001;function constrainDistance(p,q,op,distance,{axis:axis,masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=axis?new optim_1.Vector(axis[0],axis[1]).normalize():pq.clone().normalize(),current=axis?Math.abs(pq.dot(v)):pq.length();if(">="===op&&current>=distance+kZeroThreshold)return[];if("<="===op&&current<=distance-kZeroThreshold)return[];if("="===op&&Math.abs(current-distance)<=kZeroThreshold)return[];const delta=distance-current;masses||(masses=[1,1]),pq.dot(v)<0&&v.negate();const gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1])),grads=[];return gradp.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(p,gradp)),gradq.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(q,gradq)),grads}function constrainAngle(p,q,angle,strength=1,{masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p).normalize(),pqAngle=180*Math.atan2(pq.y,pq.x)/Math.PI;let desired;if(Array.isArray(angle)){if(0===angle.length)throw Error("No angles specified");desired=angle[0];let mindiff=Number.POSITIVE_INFINITY;for(let a of angle){const diff=180-Math.abs(Math.abs(a-pqAngle)-180);diff<mindiff&&(desired=a,mindiff=diff)}}else desired=angle;const delta=strength*((pqAngle-desired-540)%360+180)/180,gradq=new optim_1.Vector(pq.y,-pq.x).multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=new optim_1.Vector(-pq.y,pq.x).multiplyScalar(delta*masses[1]/(masses[0]+masses[1]));return[new optim_1.Gradient(p,gradp),new optim_1.Gradient(q,gradq)]}function constrainOffset(p,q,op,offset,direction,{masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=new optim_1.Vector(direction[0],direction[1]).normalize(),projected=pq.dot(v);if(">="===op&&projected>=offset+kZeroThreshold)return[];if("<="===op&&projected<=offset-kZeroThreshold)return[];if("="===op&&Math.abs(projected-offset)<=kZeroThreshold)return[];const delta=offset-projected,gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1])),grads=[];return gradp.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(p,gradp)),gradq.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(q,gradq)),grads}exports.constrainDistance=constrainDistance,exports.constrainAngle=constrainAngle,exports.constrainOffset=constrainOffset;const kPadding=10;exports.positionChildren=function positionChildren(u,padding=kPadding){if(u.children.length>0){const box=new three_1.Box2;u.children.forEach(child=>{box.expandByPoint(new optim_1.Vector(child.center.x-child.shape.width/2-padding,child.center.y-child.shape.height/2-padding)),box.expandByPoint(new optim_1.Vector(child.center.x+child.shape.width/2+padding,child.center.y+child.shape.height/2+padding))}),box.getCenter(u.center);const dims=new optim_1.Vector;box.getSize(dims),u.shape.width=dims.x,u.shape.height=dims.y}return[]};const kPortSeparation=10,kPortMasses=[1e6,1];function getBounds(node){return new three_1.Box2(new optim_1.Vector(node.center.x-node.shape.width/2,node.center.y-node.shape.height/2),new optim_1.Vector(node.center.x+node.shape.width/2,node.center.y+node.shape.height/2))}function forcePairwisePower(u,v,{power:power=2,control:control=0,scalar:scalar=1}={}){const vu=(new optim_1.Vector).subVectors(u.center,v.center),delta=vu.length()-control,sign=delta>0?1:-1,mag=Math.pow(Math.max(Math.abs(delta),.1),power);Array.isArray(scalar)||(scalar=[scalar,scalar]),vu.normalize();const uv=vu.clone();return vu.multiplyScalar(mag*scalar[0]*sign),uv.multiplyScalar(-mag*scalar[1]*sign),[new optim_1.Gradient(u.center,vu),new optim_1.Gradient(v.center,uv)]}function forcePairwise(p,q,magnitude){Array.isArray(magnitude)||(magnitude=[magnitude,magnitude]);const qp=(new optim_1.Vector).subVectors(p,q).normalize(),pq=qp.clone().negate();return qp.multiplyScalar(magnitude[0]),pq.multiplyScalar(magnitude[1]),[new optim_1.Gradient(p,qp),new optim_1.Gradient(q,pq)]}function forceVector(u,magnitude,direction){const force=new optim_1.Vector(direction[0],direction[1]);return force.normalize().multiplyScalar(magnitude),[new optim_1.Gradient(u.center,force)]}exports.positionPorts=function positionPorts(u,compactness=.01,gap=8){const grads=[],ports=Object.values(u.ports),orders={};return ports.forEach(port=>{void 0!==port.order&&void 0!==port.location&&(port.location in orders||(orders[port.location]=[]),orders[port.location].push(port))}),ports.forEach(({location:location,order:order,point:point})=>{let portAxis;switch(location){case"north":portAxis=[1,0],grads.push(constrainOffset(u.center,point,"=",-u.shape.height/2,[0,1],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.width/2,{axis:[1,0],masses:kPortMasses}));break;case"south":portAxis=[1,0],grads.push(constrainOffset(u.center,point,"=",u.shape.height/2,[0,1],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.width/2,{axis:[1,0],masses:kPortMasses}));break;case"east":portAxis=[0,1],grads.push(constrainOffset(u.center,point,"=",u.shape.width/2,[1,0],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.height/2,{axis:[0,1],masses:kPortMasses}));break;case"west":portAxis=[0,1],grads.push(constrainOffset(u.center,point,"=",-u.shape.width/2,[1,0],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.height/2,{axis:[0,1],masses:kPortMasses}));break;default:grads.push(constrainDistance(u.center,point,"=",0,{masses:kPortMasses}))}location&&order&&orders[location].forEach(port=>{port.order<order&&grads.push(constrainOffset(point,port.point,"<=",kPortSeparation,portAxis))}),location&&(grads.push(forcePairwise(u.center,point,[0,-compactness*u.center.distanceTo(point)])),ports.forEach(({point:otherpoint})=>{grads.push(constrainDistance(point,otherpoint,">=",gap))}))}),grads.flat()},exports.positionNoOverlap=function positionNoOverlap(u,v){const ubounds=getBounds(u),vbounds=getBounds(v);if(!ubounds.intersectsBox(vbounds))return[];const xgrad=constrainDistance(u.center,v.center,">=",(u.shape.width+v.shape.width)/2,{axis:[1,0]}),ygrad=constrainDistance(u.center,v.center,">=",(u.shape.height+v.shape.height)/2,{axis:[0,1]}),shorter=xgrad.reduce((sum,grad)=>sum+grad.grad.length(),0)<ygrad.reduce((sum,grad)=>sum+grad.grad.length(),0)?xgrad:ygrad;function moveChildren(p,grad){p.children.length>0&&p.children.forEach(c=>{shorter.push(new optim_1.Gradient(c.center,grad)),moveChildren(c,grad)})}for(let grad of shorter)grad.point===u.center&&moveChildren(u,grad.grad),grad.point===v.center&&moveChildren(v,grad.grad);return shorter},exports.positionAlignment=function positionAlignment(nodes,axis){const[x,y]=axis;if(nodes.length<2)return[];const grads=[];for(let i=0;i<nodes.length-1;i++)grads.push(...constrainDistance(nodes[i].center,nodes[i+1].center,"=",0,{axis:[-y,x]}));return grads},exports.positionSeparation=function positionSeparation(u,v,op,separation,{masses:masses=[1,1]}={}){const uv=(new optim_1.Vector).subVectors(v.center,u.center);uv.length();const{width:uwidth,height:uheight}=u.shape,{width:vwidth,height:vheight}=v.shape,uborder=uv.y*uwidth>uv.x*uheight?new optim_1.Vector(uv.x/uv.y*uwidth,uheight):new optim_1.Vector(uwidth,uv.y/uv.x*uheight),vborder=uv.y*vwidth>uv.x*vheight?new optim_1.Vector(uv.x/uv.y*vwidth,vheight):new optim_1.Vector(vwidth,uv.y/uv.x*vheight);let interior=(uborder.length()+vborder.length())/2;return constrainDistance(u.center,v.center,op,separation+interior,{masses:masses})},exports.positionCircular=function positionCircular(u,v){return[]},exports.positionGridSnap=function positionGridSnap(u,dx,dy){const snapx=Math.floor(u.center.x/dx)*dx,snapy=Math.floor(u.center.y/dy)*dy;return constrainDistance(u.center,new optim_1.Vector(snapx,snapy),"=",0)},exports.forcePairwisePower=forcePairwisePower,exports.forcePairwise=forcePairwise,exports.forcePairwiseNodes=function forcePairwiseNodes(u,v,magnitude){const[gradu,gradv]=forcePairwise(u.center,v.center,magnitude),grads=[];return u.fixed||grads.push(gradu),v.fixed||grads.push(gradv),grads},exports.forceVector=forceVector;try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/gradients.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the vector pointing from `p` to `q`. The mass of a point determines its\ninertia i.e. with more mass it moves less. Note that because many rendering schemes make the\npositive-y axis point downwards, the angle is measured clockwise from 0 (not counter-clockwise\nas is the convention in trigonometry).\n@param p Point vector that serves as source (direction tail).\n@param q Point vector that serves as target (direction head.).\n@param angle A single angle or list of angles, in degrees within range [0, 360].\n@param strength Maximum magnitude restoring force, when vector is directly opposite the angle.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/graph/gradients.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/gradients.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - control | ^ power` and\ndirections pointing away from each other (when `f` is positive) or towards each other (when\n`f` is negative), for `f = scalar * ( || u - v || - control )`. It is possible to specify a pair\nof different `scalar` values to apply to each node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/graph/gradients.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/graph/gradients.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}},775:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils_1=__webpack_require__(776);class Storage{}exports.Storage=Storage;class BasicStorage extends Storage{constructor(nodes,edges){super(),this._nodes=nodes,this._edges=edges,this._nodeIdToIdx=new Map(nodes.map(({id:id},idx)=>[id,idx])),this._edgeIdToIdx=new Map(edges.map(({id:id},idx)=>[id,idx]))}nodes(){return Array.from(this._nodes)}edges(){return Array.from(this._edges)}node(id){const idx=this._nodeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Node with specified NodeId: ${id}`);return this._nodes[idx]}edge(id){const idx=this._edgeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Edge with specified EdgeId: ${id}`);return this._edges[idx]}bounds(){if(0==this._nodes.length)return{x:0,y:0,X:0,Y:0,width:0,height:0};let x=Number.POSITIVE_INFINITY,y=Number.POSITIVE_INFINITY,X=Number.NEGATIVE_INFINITY,Y=Number.NEGATIVE_INFINITY;return this._nodes.forEach(node=>{x=Math.min(x,node.center.x-node.shape.width/2),y=Math.min(y,node.center.y-node.shape.height/2),X=Math.max(X,node.center.x+node.shape.width/2),Y=Math.max(Y,node.center.y+node.shape.height/2)}),this._edges.forEach(edge=>{const xs=edge.path.map(pt=>pt.x),ys=edge.path.map(pt=>pt.y);x=Math.min(x,...xs),y=Math.min(y,...ys),X=Math.max(X,...xs),Y=Math.max(Y,...ys)}),{x:x,y:y,X:X,Y:Y,width:X-x,height:Y-y}}}exports.BasicStorage=BasicStorage;class StructuredStorage extends BasicStorage{constructor(nodes,edges){super(nodes,edges),this._roots=new Set,this._parents=new Map,nodes.forEach(node=>{this._roots.add(node),node.children.forEach(child=>{if(this._parents.has(child))throw Error(`Node can only have 1 parent: child NodeId ${child.id}, parent NodeId ${node.id}`);this._parents.set(child,node)})});for(let child of this._parents.keys())this._roots.delete(child);this._edgesFrom=new Map,this._edgesTo=new Map,edges.forEach(edge=>{const edgesFromSource=this._edgesFrom.get(edge.source.node);void 0===edgesFromSource?this._edgesFrom.set(edge.source.node,[edge]):edgesFromSource.push(edge);const edgesToTarget=this._edgesTo.get(edge.target.node);void 0===edgesToTarget?this._edgesTo.set(edge.target.node,[edge]):edgesToTarget.push(edge)})}parents(ns){utils_1.isIterable(ns)||(ns=[ns]);const parents=new Set;for(let node of ns){const parent=this._parents.get(node);parent&&parents.add(parent)}return parents}siblings(ns){utils_1.isIterable(ns)||(ns=[ns]);const siblings=new Set;for(let node of ns){const parent=this._parents.get(node);parent?parent.children.forEach(root=>siblings.add(root)):this._roots.forEach(root=>siblings.add(root)),siblings.delete(node)}return siblings}children(ns){return utils_1.isIterable(ns)?new Set(Array.from(ns).flatMap(n=>n.children)):new Set(ns.children)}roots(){return this._roots}ancestors(ns,{levels:levels,until:until}={}){utils_1.isIterable(ns)||(ns=[ns]);const ancestors=new Set,visited=new Set,traverse=(u,level)=>{void 0!==u&&(void 0!==levels&&level>levels||visited.has(u)||(visited.add(u),ancestors.add(u),u!==until&&traverse(this._parents.get(u),level+1)))};for(let node of ns)traverse(this._parents.get(node),1);return ancestors}descendants(ns,levels){utils_1.isIterable(ns)||(ns=[ns]);const descendants=new Set,visited=new Set,traverse=(u,level)=>{void 0!==levels&&level>levels||visited.has(u)||(visited.add(u),descendants.add(u),u.children.forEach(child=>traverse(child,level+1)))};for(let node of ns)node.children.forEach(child=>traverse(child,1));return descendants}hasAncestor(n,ancestor){let curr=this._parents.get(n);for(;;){if(void 0===curr)return!1;if(curr===ancestor)return!0;curr=this._parents.get(curr)}}hasDescendant(n,descendant){return this.hasAncestor(descendant,n)}leastCommonAncestor(u,v){const visited=new Set;let left=u,right=v;for(;left||right;){if(left){if(visited.has(left))return left;visited.add(left),left=this._parents.get(left)}if(right){if(visited.has(right))return right;visited.add(right),right=this._parents.get(right)}}}neighbors(ns){return utils_1.setUnion(this.sources(ns),this.targets(ns))}sources(ns){const sources=new Set;return this.edgesTo(ns).forEach(e=>sources.add(e.source.node)),sources}targets(ns){const targets=new Set;return this.edgesFrom(ns).forEach(e=>targets.add(e.target.node)),targets}edgesTo(ns){utils_1.isIterable(ns)||(ns=[ns]);const edgesTo=new Set;for(let node of ns){const es=this._edgesTo.get(node);es&&es.forEach(e=>edgesTo.add(e))}return edgesTo}edgesFrom(ns){utils_1.isIterable(ns)||(ns=[ns]);const edgesFrom=new Set;for(let node of ns){const es=this._edgesFrom.get(node);es&&es.forEach(e=>edgesFrom.add(e))}return edgesFrom}existsEdge(u,v,undirected=!1){const edgesFrom=this._edgesFrom.get(u);if(edgesFrom)for(let e of edgesFrom)if(e.target.node===v)return!0;if(undirected){const edgesTo=this._edgesTo.get(u);if(edgesTo)for(let e of edgesTo)if(e.source.node===v)return!0}return!1}connectedComponents(){return new Set}shortestPaths(directed=!1){const dist=new Map;let sources,targets,intermediates;this._edges.forEach(edge=>{dist.set(`${edge.source.id}|${edge.target.id}`,1),directed||dist.set(`${edge.target.id}|${edge.source.id}`,1)}),directed?(sources=this.sources(this.nodes()),targets=this.targets(this.nodes()),intermediates=utils_1.setIntersection(sources,targets)):sources=targets=intermediates=this.neighbors(this.nodes());for(let k of intermediates)for(let i of sources)for(let j of targets){let dist_ij=i===j?0:dist.get(`${i.id}|${j.id}`)||Number.POSITIVE_INFINITY,dist_ik=i===k?0:dist.get(`${i.id}|${k.id}`)||Number.POSITIVE_INFINITY,dist_kj=k===j?0:dist.get(`${k.id}|${j.id}`)||Number.POSITIVE_INFINITY;const dist_ij_new=Math.min(dist_ij,dist_ik+dist_kj);Number.isFinite(dist_ij_new)&&dist.set(`${i.id}|${j.id}`,dist_ij_new)}return(u,v)=>u===v?0:dist.get(`${u.id}|${v.id}`)}}exports.StructuredStorage=StructuredStorage;try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/storage.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/storage.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{StructuredStorage.displayName="StructuredStorage",StructuredStorage.__docgenInfo={description:"A `StructuredStorage` maintaing data structures to make node hierarchy and edge traversal easier.",displayName:"StructuredStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#StructuredStorage"]={docgenInfo:StructuredStorage.__docgenInfo,name:"StructuredStorage",path:"src/graph/storage.ts#StructuredStorage"})}catch(__react_docgen_typescript_loader_error){}},776:function(module,exports,__webpack_require__){"use strict";function isIterable(obj){return null!=obj&&"function"==typeof obj[Symbol.iterator]}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isIterable=isIterable,exports.setIntersection=function setIntersection(x,y){const intersection=new Set;return x.size<y.size?x.forEach(elem=>{y.has(elem)&&intersection.add(elem)}):y.forEach(elem=>{x.has(elem)&&intersection.add(elem)}),intersection},exports.setUnion=function setUnion(x,y){return new Set([...x,...y])};try{isIterable.displayName="isIterable",isIterable.__docgenInfo={description:"",displayName:"isIterable",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/utils.ts#isIterable"]={docgenInfo:isIterable.__docgenInfo,name:"isIterable",path:"src/graph/utils.ts#isIterable"})}catch(__react_docgen_typescript_loader_error){}},777:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(147);class Layout{}exports.Layout=Layout;class ForceConstraintLayout extends Layout{constructor(storage,forceIterFn,constraintIterFn,config={}){super(),this.storage=storage,this.forceIterFn=forceIterFn,this.constraintIterFn=constraintIterFn;const{numSteps:numSteps=10,numForceIters:numForceIters=1,numConstraintIters:numConstraintIters=10,forceOptimizer:forceOptimizer=new optim_1.BasicOptimizer(1),constraintOptimizer:constraintOptimizer=new optim_1.BasicOptimizer(1),onStart:onStart=(()=>!0),onStep:onStep=(()=>!0),onEnd:onEnd=(()=>void 0)}=config;this.config={numSteps:numSteps,numForceIters:numForceIters,numConstraintIters:numConstraintIters,forceOptimizer:forceOptimizer,constraintOptimizer:constraintOptimizer,onStart:onStart,onStep:onStep,onEnd:onEnd},this.steps=0}start(){const{onStart:onStart,onEnd:onEnd}=this.config;if(onStart(this.storage,this.steps)){for(;this.steps<this.config.numSteps;)if(this.steps+=1,!1===this.step())return;onEnd(this.storage,this.steps)}}step(){const{numForceIters:numForceIters,numConstraintIters:numConstraintIters,forceOptimizer:forceOptimizer,constraintOptimizer:constraintOptimizer,onStep:onStep}=this.config;for(let i=1;i<=numForceIters;i++){const forceGradGen=this.forceIterFn(this.storage,this.steps,i);let forceGrads;for(;(forceGrads=forceGradGen.next()).value&&forceOptimizer.step(forceGrads.value),!forceGrads.done;);forceOptimizer.update()}for(let j=1;j<=numConstraintIters;j++){const constraintGradGen=this.constraintIterFn(this.storage,this.steps,j);let constraintGrads;for(;(constraintGrads=constraintGradGen.next()).value&&constraintOptimizer.step(constraintGrads.value),!constraintGrads.done;);constraintOptimizer.update()}return onStep(this.storage,this.steps)}onStart(onStart){this.config.onStart=onStart}onStep(onStep){this.config.onStep=onStep}onEnd(onEnd){this.config.onEnd=onEnd}}exports.ForceConstraintLayout=ForceConstraintLayout;try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/layout.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/graph/layout.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},778:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports.kGraphTwo={nodes:[{id:"n0",shape:{width:20,height:20}},{id:"n1",shape:{width:20,height:20}}],edges:[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}}]}},779:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(127),addon_knobs_1=__webpack_require__(204),src_1=__webpack_require__(206),Graph_1=__webpack_require__(207),schemas_simple_1=__webpack_require__(780),schemas_compound_1=__webpack_require__(781);react_2.storiesOf("force models",module).add("spring-electrical w/ simple nodes",()=>{const[nodes,edges]=src_1.fromSchema(schemas_simple_1.kGraphSimple.nodes,schemas_simple_1.kGraphSimple.edges),elems=new src_1.BasicStorage(nodes,edges),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),repulsive=addon_knobs_1.number("repulsive",50),attractive=addon_knobs_1.number("attractive",1),layout=new src_1.ForceConstraintLayout(elems,function*(elems){const visited=new Set;for(let u of elems.nodes()){visited.add(u);for(let v of elems.nodes())visited.has(v)||u.fixed&&v.fixed||(yield src_1.forcePairwisePower(u,v,{power:-1,scalar:repulsive}))}for(let e of elems.edges())yield src_1.forcePairwisePower(e.source.node,e.target.node,{power:1,scalar:-attractive})},function*(elems){for(let u of elems.nodes())yield src_1.positionPorts(u)},{numSteps:numSteps,numConstraintIters:3,forceOptimizer:new src_1.TrustRegionOptimizer({lrInitial:.4,lrMax:.6,lrMin:.001})});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("spring-electrical w/ compound nodes",()=>{const[nodes,edges]=src_1.fromSchema([...schemas_compound_1.kGraphCompound.nodesChildren,...schemas_compound_1.kGraphCompound.nodesParents],schemas_compound_1.kGraphCompound.edges),elems=new src_1.StructuredStorage(nodes,edges),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),repulsive=addon_knobs_1.number("repulsive",50),attractive=addon_knobs_1.number("attractive",.5),compactness=addon_knobs_1.number("group compactness",.5),layout=new src_1.ForceConstraintLayout(elems,function*(elems){const visited=new Set;for(let u of elems.nodes()){if(visited.add(u),u.children.length>0)for(let child of u.children)yield src_1.forcePairwisePower(u,child,{power:1,scalar:-compactness});for(let v of elems.nodes())visited.has(v)||(yield src_1.forcePairwisePower(u,v,{power:-1,scalar:repulsive}))}for(let e of elems.edges())yield src_1.forcePairwisePower(e.source.node,e.target.node,{power:1,scalar:-attractive})},function*(elems,step){for(let u of elems.nodes()){if(step>15)for(let sibling of elems.siblings(u))yield src_1.positionNoOverlap(u,sibling);yield src_1.positionChildren(u),yield src_1.positionPorts(u)}},{numSteps:numSteps,numConstraintIters:3,forceOptimizer:new src_1.TrustRegionOptimizer({lrInitial:.4,lrMax:.6,lrMin:.001})});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0,nodeColor:n=>n.meta&&n.meta.group||0})}).add("spring w/ simple nodes",()=>{const[nodes,edges]=src_1.fromSchema(schemas_simple_1.kGraphSimple.nodes,schemas_simple_1.kGraphSimple.edges),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",15),layout=new src_1.ForceConstraintLayout(elems,function*(elems){const visited=new Set;for(let u of elems.nodes()){visited.add(u);for(let v of elems.nodes()){if(visited.has(v))continue;if(u.fixed&&v.fixed)continue;u.fixed,v.fixed;const uvPath=shortestPath(u,v);if(void 0===uvPath)continue;const idealDistance=idealLength*uvPath,actualDistance=u.center.distanceTo(v.center);elems.existsEdge(u,v,!0)?actualDistance>idealLength&&(yield src_1.forcePairwise(u.center,v.center,-(actualDistance-idealLength))):actualDistance<idealDistance&&(yield src_1.forcePairwiseNodes(u,v,idealDistance-actualDistance))}}},function*(elems,step){for(let u of elems.nodes())yield src_1.positionPorts(u)},{numSteps:numSteps,numConstraintIters:5,numForceIters:5,forceOptimizer:new src_1.TrustRegionOptimizer({lrInitial:.4,lrMax:.8,lrMin:.001})});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0})}).add("spring w/ compound nodes",()=>{const[nodes,edges]=src_1.fromSchema([...schemas_compound_1.kGraphCompound.nodesChildren,...schemas_compound_1.kGraphCompound.nodesParents],schemas_compound_1.kGraphCompound.edges),elems=new src_1.StructuredStorage(nodes,edges),shortestPath=elems.shortestPaths(),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:200,step:1}),idealLength=addon_knobs_1.number("ideal length",30),compactness=addon_knobs_1.number("group compactness",2),layout=new src_1.ForceConstraintLayout(elems,function*(elems){const visited=new Set;for(let u of elems.nodes()){if(visited.add(u),u.children.length>0)for(let child of u.children)yield src_1.forcePairwiseNodes(u,child,-compactness*u.center.distanceTo(child.center));for(let v of elems.nodes()){if(visited.has(v))continue;if(u.fixed&&v.fixed)continue;const[wu,wv]=[u.fixed?0:1,v.fixed?0:1],uvPath=shortestPath(u,v);if(void 0===uvPath)continue;const idealDistance=idealLength*uvPath,actualDistance=u.center.distanceTo(v.center);if(elems.existsEdge(u,v,!0)&&actualDistance>idealLength){const delta=actualDistance-idealLength;yield src_1.forcePairwiseNodes(u,v,[-wu*delta,-wv*delta])}else if(actualDistance<idealDistance){const delta=idealDistance-actualDistance;yield src_1.forcePairwiseNodes(u,v,[wu*delta,wv*delta])}}}},function*(elems,step){for(let u of elems.nodes()){if(step>20)for(let sibling of elems.siblings(u))yield src_1.positionNoOverlap(u,sibling);yield src_1.positionChildren(u),yield src_1.positionPorts(u)}},{numSteps:numSteps,numConstraintIters:5,numForceIters:5,forceOptimizer:new src_1.TrustRegionOptimizer({lrInitial:.4,lrMax:.8,lrMin:.001})});return react_1.default.createElement(Graph_1.Graph,{key:`${Math.random()}`,layout:layout,storage:elems,animated:!0,interactive:!0,nodeColor:n=>n.meta&&n.meta.group||0})})}).call(this,__webpack_require__(27)(module))},780:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphSimple={nodes:[],edges:[]};exports.kGraphSimple=kGraphSimple;for(let n=0;n<80;n++)kGraphSimple.nodes.push({id:`n${n}`,shape:{width:15,height:15}});[{t:1,s:0},{t:2,s:0},{t:9,s:0},{t:11,s:0},{t:78,s:1},{t:3,s:2},{t:4,s:3},{t:5,s:4},{t:6,s:5},{t:10,s:6},{t:8,s:7},{t:11,s:7},{t:12,s:8},{t:18,s:9},{t:35,s:10},{t:13,s:12},{t:14,s:12},{t:15,s:12},{t:16,s:12},{t:17,s:12},{t:19,s:12},{t:20,s:12},{t:21,s:12},{t:23,s:12},{t:25,s:12},{t:26,s:12},{t:28,s:12},{t:29,s:12},{t:31,s:12},{t:24,s:13},{t:45,s:14},{t:22,s:15},{t:49,s:16},{t:30,s:18},{t:39,s:19},{t:40,s:20},{t:50,s:21},{t:27,s:22},{t:63,s:23},{t:72,s:24},{t:60,s:26},{t:68,s:27},{t:59,s:29},{t:32,s:31},{t:33,s:31},{t:34,s:31},{t:36,s:31},{t:37,s:31},{t:38,s:31},{t:58,s:32},{t:75,s:33},{t:41,s:34},{t:48,s:35},{t:76,s:36},{t:42,s:37},{t:44,s:38},{t:46,s:38},{t:47,s:38},{t:43,s:39},{t:57,s:40},{t:67,s:41},{t:74,s:42},{t:51,s:43},{t:52,s:48},{t:53,s:48},{t:54,s:48},{t:55,s:48},{t:56,s:48},{t:61,s:48},{t:62,s:48},{t:64,s:62},{t:65,s:62},{t:66,s:62},{t:69,s:62},{t:70,s:69},{t:71,s:69},{t:73,s:69},{t:77,s:69},{t:79,s:78}].forEach(({s:s,t:t})=>{kGraphSimple.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})},781:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphCompound={nodesChildren:[],nodesParents:[{id:"p0",children:[],meta:{group:0}},{id:"p1",children:[],meta:{group:1}},{id:"p2",children:[],meta:{group:2}},{id:"p3",children:[],meta:{group:3}},{id:"p4",children:[],meta:{group:4}},{id:"p5",children:[],meta:{group:5}},{id:"p6",children:[],meta:{group:6}},{id:"p7",children:[],meta:{group:7}},{id:"p8",children:[],meta:{group:8}},{id:"p9",children:[],meta:{group:9}},{id:"p10",children:[],meta:{group:10}}],edges:[]};exports.kGraphCompound=kGraphCompound;[1,1,1,1,1,1,1,1,1,1,2,2,3,2,2,2,3,3,3,3,3,3,3,3,4,4,5,4,0,2,3,2,2,2,2,2,2,2,2,4,6,4,4,5,0,0,7,7,8,5,5,5,5,5,5,8,5,8,8,8,8,8,8,8,8,8,8,9,4,4,4,4,5,10,10,4,8].forEach((parent,child)=>{kGraphCompound.nodesChildren.push({id:`n${child}`,shape:{width:15,height:15},meta:{group:parent}}),kGraphCompound.nodesParents[parent].children.push(`n${child}`)}),[{s:1,t:0},{s:2,t:0},{s:3,t:0},{s:3,t:2},{s:4,t:0},{s:5,t:0},{s:6,t:0},{s:7,t:0},{s:8,t:0},{s:9,t:0},{s:11,t:10},{s:11,t:3},{s:11,t:2},{s:11,t:0},{s:12,t:11},{s:13,t:11},{s:14,t:11},{s:15,t:11},{s:17,t:16},{s:18,t:16},{s:18,t:17},{s:19,t:16},{s:19,t:17},{s:19,t:18},{s:20,t:16},{s:20,t:17},{s:20,t:18},{s:20,t:19},{s:21,t:16},{s:21,t:17},{s:21,t:18},{s:21,t:19},{s:21,t:20},{s:22,t:16},{s:22,t:17},{s:22,t:18},{s:22,t:19},{s:22,t:20},{s:22,t:21},{s:23,t:16},{s:23,t:17},{s:23,t:18},{s:23,t:19},{s:23,t:20},{s:23,t:21},{s:23,t:22},{s:23,t:12},{s:23,t:11},{s:24,t:23},{s:24,t:11},{s:25,t:24},{s:25,t:23},{s:25,t:11},{s:26,t:24},{s:26,t:11},{s:26,t:16},{s:26,t:25},{s:27,t:11},{s:27,t:23},{s:27,t:25},{s:27,t:24},{s:27,t:26},{s:28,t:11},{s:28,t:27},{s:29,t:23},{s:29,t:27},{s:29,t:11},{s:30,t:23},{s:31,t:30},{s:31,t:11},{s:31,t:23},{s:31,t:27},{s:32,t:11},{s:33,t:11},{s:33,t:27},{s:34,t:11},{s:34,t:29},{s:35,t:11},{s:35,t:34},{s:35,t:29},{s:36,t:34},{s:36,t:35},{s:36,t:11},{s:36,t:29},{s:37,t:34},{s:37,t:35},{s:37,t:36},{s:37,t:11},{s:37,t:29},{s:38,t:34},{s:38,t:35},{s:38,t:36},{s:38,t:37},{s:38,t:11},{s:38,t:29},{s:39,t:25},{s:40,t:25},{s:41,t:24},{s:41,t:25},{s:42,t:41},{s:42,t:25},{s:42,t:24},{s:43,t:11},{s:43,t:26},{s:43,t:27},{s:44,t:28},{s:44,t:11},{s:45,t:28},{s:47,t:46},{s:48,t:47},{s:48,t:25},{s:48,t:27},{s:48,t:11},{s:49,t:26},{s:49,t:11},{s:50,t:49},{s:50,t:24},{s:51,t:49},{s:51,t:26},{s:51,t:11},{s:52,t:51},{s:52,t:39},{s:53,t:51},{s:54,t:51},{s:54,t:49},{s:54,t:26},{s:55,t:51},{s:55,t:49},{s:55,t:39},{s:55,t:54},{s:55,t:26},{s:55,t:11},{s:55,t:16},{s:55,t:25},{s:55,t:41},{s:55,t:48},{s:56,t:49},{s:56,t:55},{s:57,t:55},{s:57,t:41},{s:57,t:48},{s:58,t:55},{s:58,t:48},{s:58,t:27},{s:58,t:57},{s:58,t:11},{s:59,t:58},{s:59,t:55},{s:59,t:48},{s:59,t:57},{s:60,t:48},{s:60,t:58},{s:60,t:59},{s:61,t:48},{s:61,t:58},{s:61,t:60},{s:61,t:59},{s:61,t:57},{s:61,t:55},{s:62,t:55},{s:62,t:58},{s:62,t:59},{s:62,t:48},{s:62,t:57},{s:62,t:41},{s:62,t:61},{s:62,t:60},{s:63,t:59},{s:63,t:48},{s:63,t:62},{s:63,t:57},{s:63,t:58},{s:63,t:61},{s:63,t:60},{s:63,t:55},{s:64,t:55},{s:64,t:62},{s:64,t:48},{s:64,t:63},{s:64,t:58},{s:64,t:61},{s:64,t:60},{s:64,t:59},{s:64,t:57},{s:64,t:11},{s:65,t:63},{s:65,t:64},{s:65,t:48},{s:65,t:62},{s:65,t:58},{s:65,t:61},{s:65,t:60},{s:65,t:59},{s:65,t:57},{s:65,t:55},{s:66,t:64},{s:66,t:58},{s:66,t:59},{s:66,t:62},{s:66,t:65},{s:66,t:48},{s:66,t:63},{s:66,t:61},{s:66,t:60},{s:67,t:57},{s:68,t:25},{s:68,t:11},{s:68,t:24},{s:68,t:27},{s:68,t:48},{s:68,t:41},{s:69,t:25},{s:69,t:68},{s:69,t:11},{s:69,t:24},{s:69,t:27},{s:69,t:48},{s:69,t:41},{s:70,t:25},{s:70,t:69},{s:70,t:68},{s:70,t:11},{s:70,t:24},{s:70,t:27},{s:70,t:41},{s:70,t:58},{s:71,t:27},{s:71,t:69},{s:71,t:68},{s:71,t:70},{s:71,t:11},{s:71,t:48},{s:71,t:41},{s:71,t:25},{s:72,t:26},{s:72,t:27},{s:72,t:11},{s:73,t:48},{s:74,t:48},{s:74,t:73},{s:75,t:69},{s:75,t:68},{s:75,t:25},{s:75,t:48},{s:75,t:41},{s:75,t:70},{s:75,t:71},{s:76,t:64},{s:76,t:65},{s:76,t:66},{s:76,t:63},{s:76,t:62},{s:76,t:48},{s:76,t:58}].forEach(({s:s,t:t})=>{kGraphCompound.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})},782:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(127),Graph_1=__webpack_require__(207),src_1=__webpack_require__(206);react_2.storiesOf("rendering",module).add("simple nodes/edges",()=>{const[nodes,edges]=src_1.fromSchema([{id:"n0",shape:{width:20,height:20},center:{x:10,y:30}},{id:"n1",shape:{width:20,height:40},center:{x:60,y:30}}],[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}}]),storage=new src_1.BasicStorage(nodes,edges),layout=new src_1.ForceConstraintLayout(storage,function*(){},function*(){});return react_1.default.createElement(Graph_1.Graph,{storage:storage,layout:layout})})}).call(this,__webpack_require__(27)(module))}},[[337,1,2]]]);
//# sourceMappingURL=main.55d896e6eb2a7674b1b8.bundle.js.map