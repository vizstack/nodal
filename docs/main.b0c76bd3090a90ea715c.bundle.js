(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{146:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(758)),__export(__webpack_require__(759));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/optim/index.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}},335:function(module,exports,__webpack_require__){__webpack_require__(336),__webpack_require__(447),module.exports=__webpack_require__(448)},358:function(module,exports){},448:function(module,exports,__webpack_require__){"use strict";(function(module){Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__webpack_require__(243),addon_info_1=__webpack_require__(599),addon_knobs_1=__webpack_require__(327);react_1.addDecorator(addon_info_1.withInfo),react_1.addDecorator(addon_knobs_1.withKnobs);const req=__webpack_require__(755);react_1.configure(function loadStories(){req.keys().forEach(req)},module)}).call(this,__webpack_require__(31)(module))},602:function(module,exports,__webpack_require__){var map={"./nestedObjectAssign":290,"./nestedObjectAssign.js":290};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=602},755:function(module,exports,__webpack_require__){var map={"./graph.stories.tsx":756};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function webpackContextKeys(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=755},756:function(module,exports,__webpack_require__){"use strict";(function(module){var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const react_1=__importDefault(__webpack_require__(0)),react_2=__webpack_require__(243),addon_knobs_1=__webpack_require__(327),three_1=__webpack_require__(204),src_1=__webpack_require__(757),Graph_1=__webpack_require__(775),schemas_simple_1=__webpack_require__(776),schemas_compound_1=__webpack_require__(777);react_2.storiesOf("interactive examples",module).add("spring-electrical model w/ simple nodes",()=>{const[nodes,edges]=src_1.fromSchema(schemas_simple_1.kGraphSimple.nodes,schemas_simple_1.kGraphSimple.edges),elems=new src_1.BasicStorage(nodes,edges),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:100,step:1}),repulsive=addon_knobs_1.number("repulsive",50),attractive=addon_knobs_1.number("attractive",1);return new src_1.ForceConstraintLayout(elems,(elems,step)=>{const grads=[],visited=new Set;for(let u of elems.nodes()){visited.add(u);for(let v of elems.nodes())visited.has(v)||grads.push(src_1.forcePairwisePower(u,v,{power:-1,scalar:repulsive}))}for(let e of elems.edges())grads.push(src_1.forcePairwisePower(e.source.node,e.target.node,{power:1,scalar:-attractive}));return grads.flat()},(elems,step,iter)=>{const grads=[];for(let u of elems.nodes())grads.push(src_1.positionPorts(u));return grads.flat()},{numSteps:numSteps,numConstraintIters:3}).start(),react_1.default.createElement(Graph_1.Graph,{nodes:elems.nodes(),edges:elems.edges(),bounds:elems.bounds()})}).add("spring-electrical model w/ compound nodes",()=>{const[nodes,edges]=src_1.fromSchema([...schemas_compound_1.kGraphCompound.nodesChildren,...schemas_compound_1.kGraphCompound.nodesParents],schemas_compound_1.kGraphCompound.edges),elems=new src_1.BasicStorage(nodes,edges),numSteps=addon_knobs_1.number("# timesteps",100,{range:!0,min:0,max:100,step:1}),repulsive=addon_knobs_1.number("repulsive",50),attractive=addon_knobs_1.number("attractive",.2),compactness=addon_knobs_1.number("group compactness",.2),parents=new Map;return elems.nodes().forEach(parent=>{parent.children.forEach(child=>{parents.set(child,parent)})}),new src_1.ForceConstraintLayout(elems,(elems,step)=>{const grads=[],visited=new Set;for(let u of elems.nodes()){visited.add(u),u.children.length>0&&u.children.forEach(child=>{grads.push(src_1.forcePairwisePower(u,child,{power:1,scalar:-compactness}))});for(let v of elems.nodes())visited.has(v)||grads.push(src_1.forcePairwisePower(u,v,{power:-1,scalar:repulsive}))}for(let e of elems.edges())grads.push(src_1.forcePairwisePower(e.source.node,e.target.node,{power:1,scalar:-attractive}));return grads.flat()},(elems,step,iter)=>{const grads=[];for(let u of elems.nodes()){if(u.children.length>0){const box=new three_1.Box2;u.children.forEach(child=>{box.expandByPoint(new three_1.Vector2(child.center.x-child.shape.width/2,child.center.y-child.shape.height/2)),box.expandByPoint(new three_1.Vector2(child.center.x+child.shape.width/2,child.center.y+child.shape.height/2))}),box.getCenter(u.center);const dims=new three_1.Vector2;box.getSize(dims),u.shape.width=dims.x,u.shape.height=dims.y}grads.push(src_1.positionPorts(u))}for(let u of elems.nodes()){const parent=parents.get(u);parent&&parent.children.forEach(child=>{grads.push(src_1.positionNoOverlap(u,child))})}return grads.flat()},{numSteps:numSteps,numConstraintIters:3}).start(),react_1.default.createElement(Graph_1.Graph,{nodes:elems.nodes(),edges:elems.edges(),bounds:elems.bounds()})}),react_2.storiesOf("tests",module).add("render nodes/edges",()=>{const[nodes,edges]=src_1.fromSchema([{id:"n0",shape:{width:50,height:50},center:{x:50,y:75}},{id:"n1",shape:{width:50,height:100},center:{x:150,y:75}}],[{id:"e0->1",source:{id:"n0"},target:{id:"n1"}}]);return react_1.default.createElement(Graph_1.Graph,{nodes:nodes,edges:edges})})}).call(this,__webpack_require__(31)(module))},757:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(146)),__export(__webpack_require__(760));try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/index.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/index.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/index.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/index.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/index.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/index.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/index.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/index.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/index.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the segment between points. The mass of a point determines its inertia\ni.e. with more mass it moves less.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/index.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{positionPorts.displayName="positionPorts",positionPorts.__docgenInfo={description:"",displayName:"positionPorts",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#positionPorts"]={docgenInfo:positionPorts.__docgenInfo,name:"positionPorts",path:"src/index.ts#positionPorts"})}catch(__react_docgen_typescript_loader_error){}try{positionGridSnap.displayName="positionGridSnap",positionGridSnap.__docgenInfo={description:"",displayName:"positionGridSnap",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#positionGridSnap"]={docgenInfo:positionGridSnap.__docgenInfo,name:"positionGridSnap",path:"src/index.ts#positionGridSnap"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - shift | ^ power` and\ndirections pointing away from each other (when `scalar` is positive) or towards each other (when\n`scalar` is negative). It is possible to specify a pair of different `scalar` values to apply to\neach node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/index.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/index.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/index.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/index.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},758:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Scheduler{constructor(defaultValue=0){this._interpolators=[],this._end=0,this._defaultValue=defaultValue}to(t,fn){if(t<=this._end)throw Error(`Already set in range [0, ${this._end}); got t = ${t}`);return this._interpolators.push([this._end,t,fn]),this._end=t,this}for(deltat,fn){if(deltat<1)throw Error(`New range must be positive; got deltat = ${deltat}`);return this._interpolators.push([this._end,this._end+deltat,fn]),this._end+=deltat,this}get(t){if(t<0||this._end<=t)return this._defaultValue;for(const[start,end,fn]of this._interpolators)if(start<=t&&t<end)return fn((t-start)/(end-start));return this._defaultValue}}function constant(value){return u=>value}function linear(start,end){return u=>(end-start)*u+start}function exponential(start,end,curvature=1){return Math.abs(curvature)<.1?linear(start,end):start<=end?u=>(Math.pow(2,curvature*u)-1)/(Math.pow(2,curvature)-1)*(end-start)+start:u=>(Math.pow(2,curvature*(1-u))-1)/(Math.pow(2,curvature)-1)*(start-end)+end}exports.Scheduler=Scheduler,exports.constant=constant,exports.linear=linear,exports.exponential=exponential;try{constant.displayName="constant",constant.__docgenInfo={description:"Constant `value` throughout the range.\n@param value",displayName:"constant",props:{toString:{defaultValue:null,description:"Returns a string representation of an object.\n@param radix Specifies a radix for converting numeric values to strings. This value is only used for numbers.",name:"toString",required:!0,type:{name:"(radix?: number) => string"}},toFixed:{defaultValue:null,description:"Returns a string representing a number in fixed-point notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toFixed",required:!0,type:{name:"(fractionDigits?: number) => string"}},toExponential:{defaultValue:null,description:"Returns a string containing a number represented in exponential notation.\n@param fractionDigits Number of digits after the decimal point. Must be in the range 0 - 20, inclusive.",name:"toExponential",required:!0,type:{name:"(fractionDigits?: number) => string"}},toPrecision:{defaultValue:null,description:"Returns a string containing a number represented either in exponential or fixed-point notation with a specified number of digits.\n@param precision Number of significant digits. Must be in the range 1 - 21, inclusive.",name:"toPrecision",required:!0,type:{name:"(precision?: number) => string"}},valueOf:{defaultValue:null,description:"Returns the primitive value of the specified object.",name:"valueOf",required:!0,type:{name:"() => number"}},toLocaleString:{defaultValue:null,description:"Converts a number to a string by using the current or specified locale.\n@param locales A locale string or array of locale strings that contain one or more language or locale tags. If you include more than one locale string, list them in descending order of priority so that the first entry is the preferred locale. If you omit this parameter, the default locale of the JavaScript runtime is used.\n@param options An object that contains one or more properties that specify comparison options.",name:"toLocaleString",required:!0,type:{name:"(locales?: string | string[], options?: NumberFormatOptions) => string"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#constant"]={docgenInfo:constant.__docgenInfo,name:"constant",path:"src/optim/scheduler.ts#constant"})}catch(__react_docgen_typescript_loader_error){}try{linear.displayName="linear",linear.__docgenInfo={description:"Linearly interpolates from `start` to `end`.\n@param start\n@param end",displayName:"linear",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#linear"]={docgenInfo:linear.__docgenInfo,name:"linear",path:"src/optim/scheduler.ts#linear"})}catch(__react_docgen_typescript_loader_error){}try{exponential.displayName="exponential",exponential.__docgenInfo={description:"Exponentially interpolates from `start` to `end`, with different curvature.\n@param start\n@param end\n@param curvature Positive is concave up, while negative is concave down. Magnitude controls the steepness of\nthe ascent/descent.",displayName:"exponential",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#exponential"]={docgenInfo:exponential.__docgenInfo,name:"exponential",path:"src/optim/scheduler.ts#exponential"})}catch(__react_docgen_typescript_loader_error){}try{Scheduler.displayName="Scheduler",Scheduler.__docgenInfo={description:"A `Scheduler` returns some numeric value that changes over time according to a sequence of\ninterpolation functions.",displayName:"Scheduler",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/scheduler.ts#Scheduler"]={docgenInfo:Scheduler.__docgenInfo,name:"Scheduler",path:"src/optim/scheduler.ts#Scheduler"})}catch(__react_docgen_typescript_loader_error){}},759:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(204);class Vector extends three_1.Vector2{}exports.Vector=Vector;class Gradient{constructor(point,grad){this.point=point,this.grad=grad}}exports.Gradient=Gradient;class Optimizer{}exports.Optimizer=Optimizer;class BasicOptimizer extends Optimizer{constructor(lr=1){super(),this.lr=lr}step(gradients){gradients.forEach(grad=>grad.point.add(grad.grad.clone().multiplyScalar(this.lr)))}}exports.BasicOptimizer=BasicOptimizer;class TrustRegionOptimizer extends Optimizer{constructor(config={}){super(),this._numStepsImproved=0,this._prevEnergy=Number.MAX_VALUE;const{lrInitial:lrInitial=1,adaption:adaption=.9,wait:wait=5,lrMax:lrMax=1,lrMin:lrMin=.01}=config;if(adaption>1)throw Error("Must specify value of `adaption` <= 1");if(wait<0)throw Error("Must specify value of `wait` >= 0");this._config={lrInitial:lrInitial,adaption:adaption,wait:wait,lrMax:lrMax,lrMin:lrMin},this._lr=lrInitial}_update(currEnergy){currEnergy<this._prevEnergy?(this._numStepsImproved+=1,this._numStepsImproved>=this._config.wait&&(this._numStepsImproved=0,this._lr/=this._config.adaption)):(this._numStepsImproved=0,this._lr*=this._config.adaption)}step(gradients){let currEnergy=0;gradients.forEach(grad=>{grad.point.add(grad.grad.clone().multiplyScalar(this._lr)),currEnergy+=grad.grad.length()}),this._update(currEnergy)}}exports.TrustRegionOptimizer=TrustRegionOptimizer;try{Vector.displayName="Vector",Vector.__docgenInfo={description:"A `Vector` in 2D space is the base entity manipulated by the `Optimizer`. All higher-level\nentities (like simple and compound nodes, ports, etc.) are represented as a collection of points.",displayName:"Vector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Vector"]={docgenInfo:Vector.__docgenInfo,name:"Vector",path:"src/optim/optimizer.ts#Vector"})}catch(__react_docgen_typescript_loader_error){}try{Gradient.displayName="Gradient",Gradient.__docgenInfo={description:'A `Gradient` associates a point `Vector` to a gradient `Vector` that the `Optimizer` uses to\nupdate the point\'s location in space. A `Gradient` can act as a "soft" force or a "hard"\nconstraint depending on how aggressively the `Optimizer` enforces it (through the learning rate).',displayName:"Gradient",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Gradient"]={docgenInfo:Gradient.__docgenInfo,name:"Gradient",path:"src/optim/optimizer.ts#Gradient"})}catch(__react_docgen_typescript_loader_error){}try{Optimizer.displayName="Optimizer",Optimizer.__docgenInfo={description:'An `Optimizer` performs an update to a `Vector` based on a `Gradient`. It uses *gradient ascent*,\nwhich means that the gradient vector should already point in the intended direction of update and\nthe update rule takes the form: `x = x + lr * grad`. This fits with the physical iterpretation\nof a gradient as a "nudge" in a particular direction due to forces or constraints.',displayName:"Optimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#Optimizer"]={docgenInfo:Optimizer.__docgenInfo,name:"Optimizer",path:"src/optim/optimizer.ts#Optimizer"})}catch(__react_docgen_typescript_loader_error){}try{BasicOptimizer.displayName="BasicOptimizer",BasicOptimizer.__docgenInfo={description:"A `BasicOptimizer` uses a fixed learning rate.",displayName:"BasicOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#BasicOptimizer"]={docgenInfo:BasicOptimizer.__docgenInfo,name:"BasicOptimizer",path:"src/optim/optimizer.ts#BasicOptimizer"})}catch(__react_docgen_typescript_loader_error){}try{TrustRegionOptimizer.displayName="TrustRegionOptimizer",TrustRegionOptimizer.__docgenInfo={description:"A `TrustRegionOptimizer` uses an adaptive scheme to increase or decrease the learning rate based\non whether there is improvement on an energy function (lower than before).",displayName:"TrustRegionOptimizer",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/optim/optimizer.ts#TrustRegionOptimizer"]={docgenInfo:TrustRegionOptimizer.__docgenInfo,name:"TrustRegionOptimizer",path:"src/optim/optimizer.ts#TrustRegionOptimizer"})}catch(__react_docgen_typescript_loader_error){}},760:function(module,exports,__webpack_require__){"use strict";function __export(m){for(var p in m)exports.hasOwnProperty(p)||(exports[p]=m[p])}Object.defineProperty(exports,"__esModule",{value:!0}),__export(__webpack_require__(761)),__export(__webpack_require__(772)),__export(__webpack_require__(773)),__export(__webpack_require__(774));try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/index.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/index.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the segment between points. The mass of a point determines its inertia\ni.e. with more mass it moves less.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/graph/index.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/index.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{positionPorts.displayName="positionPorts",positionPorts.__docgenInfo={description:"",displayName:"positionPorts",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#positionPorts"]={docgenInfo:positionPorts.__docgenInfo,name:"positionPorts",path:"src/graph/index.ts#positionPorts"})}catch(__react_docgen_typescript_loader_error){}try{positionGridSnap.displayName="positionGridSnap",positionGridSnap.__docgenInfo={description:"",displayName:"positionGridSnap",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#positionGridSnap"]={docgenInfo:positionGridSnap.__docgenInfo,name:"positionGridSnap",path:"src/graph/index.ts#positionGridSnap"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - shift | ^ power` and\ndirections pointing away from each other (when `scalar` is positive) or towards each other (when\n`scalar` is negative). It is possible to specify a pair of different `scalar` values to apply to\neach node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/graph/index.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/graph/index.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/index.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/index.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/index.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/index.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/graph/index.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},761:function(module,exports,__webpack_require__){"use strict";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{default:mod}};Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(146),lodash_1=__webpack_require__(762),seedrandom_1=__importDefault(__webpack_require__(763)),kPortOffset=.2;function fromSchema(nodeSchemas,edgeSchemas){const nodeIdToIdx=new Map,nodes=nodeSchemas.map(({id:id,center:center,shape:shape,fixed:fixed,children:children,ports:ports,meta:meta},idx)=>{if(!id)throw Error(`Invalid NodeId: ${id}`);if(nodeIdToIdx.has(id))throw Error(`Duplicate NodeId: ${id}`);nodeIdToIdx.set(id,idx);const rand=seedrandom_1.default(id),centerpt=center?new optim_1.Vector(center.x,center.y):new optim_1.Vector(rand(),rand());return{id:id,center:centerpt,shape:shape||{width:0,height:0},fixed:fixed||!1,children:children||[],ports:ports?lodash_1.mapValues(ports,({location:location,order:order,point:point})=>({location:location,order:order,point:point?new optim_1.Vector(point.x,point.y):new optim_1.Vector(centerpt.x+kPortOffset*rand(),centerpt.y+kPortOffset*rand())})):{},meta:meta}});function processEndpoint(edgeId,type,nodeId,port){const idx=nodeIdToIdx.get(nodeId);if(void 0===idx)throw Error(`Invalid ${type} NodeId: ${nodeId}, edge ${edgeId}`);const node=nodes[idx];let point;if(port)throw port in node.ports&&(point=node.ports[port].point),Error(`Invalid ${type} port name: ${port}, ${type} ${nodeId}, edge ${edgeId}`);{const rand=seedrandom_1.default(`${edgeId}-${type}`);port=`_${edgeId}`,point=new optim_1.Vector(node.center.x+kPortOffset*rand(),node.center.y+kPortOffset*rand()),node.ports[port]={point:point}}return{id:nodeId,port:port,node:node,point:point}}nodes.forEach(node=>node.children=node.children.map(id=>{const childIdx=nodeIdToIdx.get(id);if(void 0===childIdx)throw Error(`Invalid child NodeId: ${id}, parent ${node.id}`);return nodes[childIdx]}));const edgeIdToIdx=new Set,edges=edgeSchemas.map(({id:id,source:source,target:target,path:path,meta:meta})=>{if(!id)throw Error(`Invalid EdgeId: ${id}`);if(edgeIdToIdx.has(id))throw Error(`Duplicate EdgeId: ${id}`);edgeIdToIdx.add(id);const s=processEndpoint(id,"source",source.id,source.port),t=processEndpoint(id,"target",target.id,target.port);return{id:id,source:s,target:t,path:path?path.map(({x:x,y:y})=>new optim_1.Vector(x,y)):[s.point,t.point],meta:meta}});return[nodes,edges]}exports.fromSchema=fromSchema;try{fromSchema.displayName="fromSchema",fromSchema.__docgenInfo={description:"Transform lightweight `NodeSchema` and `EdgeSchema` data structures into `Node` and `Edge`\nobjects. See documentation for `NodeSchema` and `EdgeSchema` for more details.\n@param nodeSchemas\n@param edgeSchemas",displayName:"fromSchema",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/elements.ts#fromSchema"]={docgenInfo:fromSchema.__docgenInfo,name:"fromSchema",path:"src/graph/elements.ts#fromSchema"})}catch(__react_docgen_typescript_loader_error){}},771:function(module,exports){},772:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const three_1=__webpack_require__(204),optim_1=__webpack_require__(146),kZeroThreshold=.001;function constrainDistance(p,q,op,distance,{axis:axis,masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=axis?new optim_1.Vector(axis[0],axis[1]).normalize():pq.clone().normalize(),current=axis?Math.abs(pq.dot(v)):pq.length();if(">="===op&&current>=distance+kZeroThreshold)return[];if("<="===op&&current<=distance-kZeroThreshold)return[];if("="===op&&Math.abs(current-distance)<=kZeroThreshold)return[];const delta=distance-current;masses||(masses=[1,1]);const gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1])),grads=[];return gradp.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(p,gradp)),gradq.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(q,gradq)),grads}function constrainAngle(p,q,angle,{masses:masses=[1,1]}={}){return[]}function constrainOffset(p,q,op,offset,direction,{masses:masses=[1,1]}={}){const pq=(new optim_1.Vector).subVectors(q,p),v=new optim_1.Vector(direction[0],direction[1]).normalize(),projected=pq.dot(v);if(">="===op&&projected>=offset+kZeroThreshold)return[];if("<="===op&&projected<=offset-kZeroThreshold)return[];if("="===op&&Math.abs(projected-offset)<=kZeroThreshold)return[];const delta=offset-projected,gradq=v.clone().multiplyScalar(delta*masses[0]/(masses[0]+masses[1])),gradp=v.clone().multiplyScalar(-delta*masses[1]/(masses[0]+masses[1])),grads=[];return gradp.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(p,gradp)),gradq.length()>kZeroThreshold&&grads.push(new optim_1.Gradient(q,gradq)),grads}exports.constrainDistance=constrainDistance,exports.constrainAngle=constrainAngle,exports.constrainOffset=constrainOffset,exports.positionChildren=function positionChildren(u,compactness){return[]};const kPortSeparation=10,kPortMasses=[1e4,1];function positionPorts(u){const grads=[],orders={};return Object.values(u.ports).forEach(port=>{void 0!==port.order&&void 0!==port.location&&(port.location in orders||(orders[port.location]=[]),orders[port.location].push(port))}),Object.values(u.ports).forEach(({location:location,order:order,point:point})=>{let portAxis;switch(location){case"north":portAxis=[1,0],grads.push(constrainOffset(u.center,point,"=",u.shape.height/2,[0,1],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.width/2,{axis:[1,0],masses:kPortMasses}));break;case"south":portAxis=[1,0],grads.push(constrainOffset(u.center,point,"=",-u.shape.height/2,[0,1],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.width/2,{axis:[1,0],masses:kPortMasses}));break;case"east":portAxis=[0,1],grads.push(constrainOffset(u.center,point,"=",u.shape.width/2,[1,0],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.height/2,{axis:[0,1],masses:kPortMasses}));break;case"west":portAxis=[0,1],grads.push(constrainOffset(u.center,point,"=",-u.shape.width/2,[1,0],{masses:kPortMasses}),constrainDistance(u.center,point,"<=",u.shape.height/2,{axis:[0,1],masses:kPortMasses}));break;default:grads.push(constrainDistance(u.center,point,"=",0,{masses:kPortMasses}))}location&&order&&orders[location].forEach(port=>{port.order<order&&grads.push(constrainDistance(point,port.point,"<=",kPortSeparation,{axis:portAxis})),port.order>order&&grads.push(constrainDistance(point,port.point,">=",kPortSeparation,{axis:portAxis}))})}),grads.flat()}function getBounds(node){return new three_1.Box2(new optim_1.Vector(node.center.x-node.shape.width/2,node.center.y-node.shape.height/2),new optim_1.Vector(node.center.x+node.shape.width/2,node.center.y+node.shape.height/2))}function positionGridSnap(u){return[]}function forcePairwisePower(u,v,{power:power=2,shift:shift=0,scalar:scalar=1}={}){const vu=(new optim_1.Vector).subVectors(u.center,v.center);let delta=vu.length()-shift;const mag=Math.pow(Math.max(Math.abs(delta),.1),power),mags=Array.isArray(scalar)?[mag*scalar[0],mag*scalar[1]]:[mag*scalar,mag*scalar];vu.normalize();const uv=vu.clone().negate();return vu.multiplyScalar(mags[0]),uv.multiplyScalar(mags[1]),[new optim_1.Gradient(u.center,vu),new optim_1.Gradient(v.center,uv)]}function forceVector(u,magnitude,direction){const force=new optim_1.Vector(direction[0],direction[1]);return force.normalize().multiplyScalar(magnitude),[new optim_1.Gradient(u.center,force)]}exports.positionPorts=positionPorts,exports.positionNoOverlap=function positionNoOverlap(u,v){const ubounds=getBounds(u),vbounds=getBounds(v);if(!ubounds.intersectsBox(vbounds))return[];const xgrad=constrainDistance(u.center,v.center,">=",(u.shape.width+v.shape.width)/2,{axis:[1,0]}),ygrad=constrainDistance(u.center,v.center,">=",(u.shape.height+v.shape.height)/2,{axis:[0,1]});return xgrad.reduce((sum,grad)=>sum+grad.grad.length(),0)<ygrad.reduce((sum,grad)=>sum+grad.grad.length(),0)?xgrad:ygrad},exports.positionAlignment=function positionAlignment(u,v,direction){return[]},exports.positionSeparation=function positionSeparation(u,v){return[]},exports.positionCircular=function positionCircular(u,v){return[]},exports.positionGridSnap=positionGridSnap,exports.forcePairwisePower=forcePairwisePower,exports.forceVector=forceVector;try{constrainDistance.displayName="constrainDistance",constrainDistance.__docgenInfo={description:"Constrains the Euclidean distance between points, optionally after projection onto an axis.\n@param p Point vector.\n@param q Point vector.\n@param op Whether to make separation equal to (`=`), greater than or equal to (`>=`), or less than or\nequal to (`<=`) the specified distance.\n@param distance Positive separation between `p` and `q`.\n@param axis Axis onto which the separation is projected. Gradients will point in opposite directions\nalong this axis. Sign/magnitude does not matter, i.e. [1, 0] is the same as [-2, 0].\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainDistance",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainDistance"]={docgenInfo:constrainDistance.__docgenInfo,name:"constrainDistance",path:"src/graph/gradients.ts#constrainDistance"})}catch(__react_docgen_typescript_loader_error){}try{constrainAngle.displayName="constrainAngle",constrainAngle.__docgenInfo={description:"Constrains the angle of the segment between points. The mass of a point determines its inertia\ni.e. with more mass it moves less.",displayName:"constrainAngle",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainAngle"]={docgenInfo:constrainAngle.__docgenInfo,name:"constrainAngle",path:"src/graph/gradients.ts#constrainAngle"})}catch(__react_docgen_typescript_loader_error){}try{constrainOffset.displayName="constrainOffset",constrainOffset.__docgenInfo={description:"Constrains the position of `q` relative to `p` by some `offset` along the `direction`. Both the\n@param p Point vector that serves as the reference.\n@param q Point vector that serves as the offset.\n@param op Whether to make offset of `q` relative to `p` equal to (`=`), greater than / equal to (`>=`),\nor less than / equal to (`<=`) the specified value.\n@param direction Direction vector onto which the offset is projected. Magnitude does not matter.\n@param offset How much along the direction vector `q` should be relative to `p`. Can be negative.\n@param masses Mass of a point determines its inertia, i.e. with more mass it moves less.",displayName:"constrainOffset",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#constrainOffset"]={docgenInfo:constrainOffset.__docgenInfo,name:"constrainOffset",path:"src/graph/gradients.ts#constrainOffset"})}catch(__react_docgen_typescript_loader_error){}try{positionPorts.displayName="positionPorts",positionPorts.__docgenInfo={description:"",displayName:"positionPorts",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#positionPorts"]={docgenInfo:positionPorts.__docgenInfo,name:"positionPorts",path:"src/graph/gradients.ts#positionPorts"})}catch(__react_docgen_typescript_loader_error){}try{positionGridSnap.displayName="positionGridSnap",positionGridSnap.__docgenInfo={description:"",displayName:"positionGridSnap",props:{id:{defaultValue:null,description:"",name:"id",required:!0,type:{name:"NodeId"}},center:{defaultValue:null,description:"",name:"center",required:!0,type:{name:"Vector"}},shape:{defaultValue:null,description:"",name:"shape",required:!0,type:{name:"{ width: number; height: number; }"}},fixed:{defaultValue:null,description:"",name:"fixed",required:!0,type:{name:"boolean"}},ports:{defaultValue:null,description:"",name:"ports",required:!0,type:{name:'Record<string, { location?: "north" | "south" | "east" | "west"; order?: number; point: Vector; }>'}},meta:{defaultValue:null,description:"",name:"meta",required:!1,type:{name:"Record<string, any>"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#positionGridSnap"]={docgenInfo:positionGridSnap.__docgenInfo,name:"positionGridSnap",path:"src/graph/gradients.ts#positionGridSnap"})}catch(__react_docgen_typescript_loader_error){}try{forcePairwisePower.displayName="forcePairwisePower",forcePairwisePower.__docgenInfo={description:"Force between a pair of nodes, with magnitude `scalar * | || u - v || - shift | ^ power` and\ndirections pointing away from each other (when `scalar` is positive) or towards each other (when\n`scalar` is negative). It is possible to specify a pair of different `scalar` values to apply to\neach node individually.",displayName:"forcePairwisePower",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#forcePairwisePower"]={docgenInfo:forcePairwisePower.__docgenInfo,name:"forcePairwisePower",path:"src/graph/gradients.ts#forcePairwisePower"})}catch(__react_docgen_typescript_loader_error){}try{forceVector.displayName="forceVector",forceVector.__docgenInfo={description:"Force acting on a single node, with `magnitude` and `direction` specified. The `direction` vector\nmay be unnormalized.",displayName:"forceVector",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/gradients.ts#forceVector"]={docgenInfo:forceVector.__docgenInfo,name:"forceVector",path:"src/graph/gradients.ts#forceVector"})}catch(__react_docgen_typescript_loader_error){}},773:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Storage{}exports.Storage=Storage;class BasicStorage extends Storage{constructor(nodes,edges){super(),this._nodes=nodes,this._edges=edges,this._nodeIdToIdx=new Map(nodes.map(({id:id},idx)=>[id,idx])),this._edgeIdToIdx=new Map(edges.map(({id:id},idx)=>[id,idx]))}nodes(){return this._nodes}edges(){return this._edges}node(id){const idx=this._nodeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Node with specified NodeId: ${id}`);return this._nodes[idx]}edge(id){const idx=this._edgeIdToIdx.get(id);if(void 0===idx)throw Error(`Could not find Edge with specified EdgeId: ${id}`);return this._edges[idx]}bounds(){if(0==this._nodes.length)return{x:0,y:0,X:0,Y:0,width:0,height:0};let x=Number.MAX_VALUE,y=Number.MAX_VALUE,X=Number.MIN_VALUE,Y=Number.MIN_VALUE;return this._nodes.forEach(node=>{x=Math.min(x,node.center.x-node.shape.width/2),y=Math.min(y,node.center.y-node.shape.height/2),X=Math.max(X,node.center.x+node.shape.width/2),Y=Math.max(Y,node.center.y+node.shape.height/2)}),this._edges.forEach(edge=>{const xs=edge.path.map(pt=>pt.x),ys=edge.path.map(pt=>pt.y);x=Math.min(x,...xs),y=Math.min(y,...ys),X=Math.max(X,...xs),Y=Math.max(Y,...ys)}),{x:x,y:y,X:X,Y:Y,width:X-x,height:Y-y}}}exports.BasicStorage=BasicStorage;try{Storage.displayName="Storage",Storage.__docgenInfo={description:"A `Storage` is a data structure that stores `Node` and `Edge` elements, with different speed/\nmemory characteristics and methods for lookup and iteration.",displayName:"Storage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#Storage"]={docgenInfo:Storage.__docgenInfo,name:"Storage",path:"src/graph/storage.ts#Storage"})}catch(__react_docgen_typescript_loader_error){}try{BasicStorage.displayName="BasicStorage",BasicStorage.__docgenInfo={description:"A `BasicStorage` utilizes a flat representation to enable Node/Edge lookup by ID in O(1)/O(1) and\ntraversal in O(n)/O(m).",displayName:"BasicStorage",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/storage.ts#BasicStorage"]={docgenInfo:BasicStorage.__docgenInfo,name:"BasicStorage",path:"src/graph/storage.ts#BasicStorage"})}catch(__react_docgen_typescript_loader_error){}},774:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const optim_1=__webpack_require__(146);class Layout{}exports.Layout=Layout;class ForceConstraintLayout extends Layout{constructor(elems,forceIterFn,constraintIterFn,config={}){super(),this.elems=elems,this.forceIterFn=forceIterFn,this.constraintIterFn=constraintIterFn;const{numSteps:numSteps=10,numForceIters:numForceIters=1,numConstraintIters:numConstraintIters=10,forceOptimizer:forceOptimizer=new optim_1.BasicOptimizer(.1),constraintOptimizer:constraintOptimizer=new optim_1.BasicOptimizer(1),onStart:onStart=(()=>!0),onStep:onStep=(()=>!0),onEnd:onEnd=(()=>void 0)}=config;this.config={numSteps:numSteps,numForceIters:numForceIters,numConstraintIters:numConstraintIters,forceOptimizer:forceOptimizer,constraintOptimizer:constraintOptimizer,onStart:onStart,onStep:onStep,onEnd:onEnd},this.steps=0}start(){const{onStart:onStart,onStep:onStep,onEnd:onEnd}=this.config;if(onStart(this.elems,this.steps)){for(;this.steps<this.config.numSteps;)if(this.steps+=1,this.step(),!1===onStep(this.elems,this.steps))return;onEnd(this.elems,this.steps)}}step(){const{numForceIters:numForceIters,numConstraintIters:numConstraintIters,forceOptimizer:forceOptimizer,constraintOptimizer:constraintOptimizer}=this.config;for(let i=1;i<=numForceIters;i++){const forceGrads=this.forceIterFn(this.elems,this.steps,i);forceOptimizer.step(forceGrads)}for(let j=1;j<=numConstraintIters;j++){const constraintGrads=this.constraintIterFn(this.elems,this.steps,j);constraintOptimizer.step(constraintGrads)}}}exports.ForceConstraintLayout=ForceConstraintLayout;try{Layout.displayName="Layout",Layout.__docgenInfo={description:"A `Layout` defines the structure of a graph layout optimization procedure. It allows both\nexecuting the entire procedure automatically and stepping through the procedure manually.",displayName:"Layout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#Layout"]={docgenInfo:Layout.__docgenInfo,name:"Layout",path:"src/graph/layout.ts#Layout"})}catch(__react_docgen_typescript_loader_error){}try{ForceConstraintLayout.displayName="ForceConstraintLayout",ForceConstraintLayout.__docgenInfo={description:"A `ForceConstraintLayout` performs a fixed number of optimization steps, and each step\nperforms some iterations of 'force' optimization then 'constraint' optimization. Whereas the\n'force' gradients are weighted by some adaptive learning rate, the 'constraint' gradients are\nalways weighted by 1. This enables the kind of 'constraint projection' described in \"Scalable\nversatile, and simple constrained graph layout\" (Dwyer 2009). Another interpretation is that\n'force' gradients have magitudes in a different space than the points (force-space), whereas\n'constraint' gradients are in the same space (position-space).",displayName:"ForceConstraintLayout",props:{}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/graph/layout.ts#ForceConstraintLayout"]={docgenInfo:ForceConstraintLayout.__docgenInfo,name:"ForceConstraintLayout",path:"src/graph/layout.ts#ForceConstraintLayout"})}catch(__react_docgen_typescript_loader_error){}},775:function(module,exports,__webpack_require__){"use strict";var __importStar=this&&this.__importStar||function(mod){if(mod&&mod.__esModule)return mod;var result={};if(null!=mod)for(var k in mod)Object.hasOwnProperty.call(mod,k)&&(result[k]=mod[k]);return result.default=mod,result};Object.defineProperty(exports,"__esModule",{value:!0});const React=__importStar(__webpack_require__(0));class Graph extends React.Component{render(){const{nodes:nodes=[],edges:edges=[],bounds:bounds}=this.props,groupComponents=[];for(let node of nodes)node.children.length>0&&groupComponents.push(React.createElement("g",{key:node.id,id:node.id},React.createElement("rect",{x:node.center.x-node.shape.width/2,y:node.center.y-node.shape.height/2,width:node.shape.width,height:node.shape.height,fill:Color.blue.base,stroke:Color.white,strokeWidth:1.5,rx:4,opacity:.3}),React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontSize:"10",fill:Color.blue.l1}},node.id.substring(1))));const leafComponents=[];for(let node of nodes)0==node.children.length&&leafComponents.push(React.createElement("g",{key:node.id,id:node.id},React.createElement("rect",{x:node.center.x-node.shape.width/2,y:node.center.y-node.shape.height/2,width:node.shape.width,height:node.shape.height,fill:Color.blue.base,stroke:Color.white,strokeWidth:1.5,rx:4}),React.createElement("text",{x:node.center.x,y:node.center.y,textAnchor:"middle",dominantBaseline:"middle",style:{fontFamily:'"Helvetica Neue", sans-serif',fontSize:"10",fill:Color.blue.l1}},node.id.substring(1))));const edgeComponents=[];for(let edge of edges)edgeComponents.push(React.createElement("g",{key:edge.id,id:edge.id},React.createElement("path",{d:"M "+edge.path.map(({x:x,y:y})=>`${x} ${y}`).join(" L "),style:{fill:"none",stroke:Color.gray.d1,strokeWidth:3,opacity:.8}})));return React.createElement("svg",{viewBox:bounds?`${bounds.x} ${bounds.y} ${bounds.width} ${bounds.height}`:void 0,width:bounds?`${bounds.width}`:"100%",height:bounds?`${bounds.height}`:"100%"},edgeComponents,groupComponents,leafComponents)}}exports.Graph=Graph;const Color={white:"#FFFFFF",black:"#000000",gray:{l2:"#F1F3F5",l1:"#E9ECEE",base:"#DEE2E6",d1:"#B8C4CF",d2:"#8895A7"},blue:{l2:"#EFF8FF",l1:"#AAD4F6",base:"#3183C8",d1:"#2368A2",d2:"#194971"},teal:{l2:"#E7FFFE",l1:"#A8EEEC",base:"#3CAEA3",d1:"#2A9187",d2:"#1B655E"},green:{l2:"#E3FCEC",l1:"#A8EEC1",base:"#38C172",d1:"#249D57",d2:"#187741"},yellow:{l2:"#FFFCF4",l1:"#FDF3D7",base:"#F4CA64",d1:"#CAA53D",d2:"#8C6D1F"},red:{l2:"#FCE8E8",l1:"#F4AAAA",base:"#DC3030",d1:"#B82020",d2:"#881B1B"}};try{Graph.displayName="Graph",Graph.__docgenInfo={description:"",displayName:"Graph",props:{nodes:{defaultValue:null,description:"",name:"nodes",required:!1,type:{name:"any"}},edges:{defaultValue:null,description:"",name:"edges",required:!1,type:{name:"any"}},bounds:{defaultValue:null,description:"",name:"bounds",required:!1,type:{name:"{ x: number; X: number; y: number; Y: number; width: number; height: number; }"}}}},"undefined"!=typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["stories/Graph.tsx#Graph"]={docgenInfo:Graph.__docgenInfo,name:"Graph",path:"stories/Graph.tsx#Graph"})}catch(__react_docgen_typescript_loader_error){}},776:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphSimple={nodes:[],edges:[]};exports.kGraphSimple=kGraphSimple;for(let n=0;n<80;n++)kGraphSimple.nodes.push({id:`n${n}`,shape:{width:15,height:15}});[{t:1,s:0},{t:2,s:0},{t:9,s:0},{t:11,s:0},{t:78,s:1},{t:3,s:2},{t:4,s:3},{t:5,s:4},{t:6,s:5},{t:10,s:6},{t:8,s:7},{t:11,s:7},{t:12,s:8},{t:18,s:9},{t:35,s:10},{t:13,s:12},{t:14,s:12},{t:15,s:12},{t:16,s:12},{t:17,s:12},{t:19,s:12},{t:20,s:12},{t:21,s:12},{t:23,s:12},{t:25,s:12},{t:26,s:12},{t:28,s:12},{t:29,s:12},{t:31,s:12},{t:24,s:13},{t:45,s:14},{t:22,s:15},{t:49,s:16},{t:30,s:18},{t:39,s:19},{t:40,s:20},{t:50,s:21},{t:27,s:22},{t:63,s:23},{t:72,s:24},{t:60,s:26},{t:68,s:27},{t:59,s:29},{t:32,s:31},{t:33,s:31},{t:34,s:31},{t:36,s:31},{t:37,s:31},{t:38,s:31},{t:58,s:32},{t:75,s:33},{t:41,s:34},{t:48,s:35},{t:76,s:36},{t:42,s:37},{t:44,s:38},{t:46,s:38},{t:47,s:38},{t:43,s:39},{t:57,s:40},{t:67,s:41},{t:74,s:42},{t:51,s:43},{t:52,s:48},{t:53,s:48},{t:54,s:48},{t:55,s:48},{t:56,s:48},{t:61,s:48},{t:62,s:48},{t:64,s:62},{t:65,s:62},{t:66,s:62},{t:69,s:62},{t:70,s:69},{t:71,s:69},{t:73,s:69},{t:77,s:69},{t:79,s:78}].forEach(({s:s,t:t})=>{kGraphSimple.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})},777:function(module,exports,__webpack_require__){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const kGraphCompound={nodesChildren:[],nodesParents:[{id:"p0",children:[]},{id:"p1",children:[]},{id:"p2",children:[]},{id:"p3",children:[]},{id:"p4",children:[]},{id:"p5",children:[]},{id:"p6",children:[]},{id:"p7",children:[]},{id:"p8",children:[]},{id:"p9",children:[]},{id:"p10",children:[]}],edges:[]};exports.kGraphCompound=kGraphCompound;[1,1,1,1,1,1,1,1,1,1,2,2,3,2,2,2,3,3,3,3,3,3,3,3,4,4,5,4,0,2,3,2,2,2,2,2,2,2,2,4,6,4,4,5,0,0,7,7,8,5,5,5,5,5,5,8,5,8,8,8,8,8,8,8,8,8,8,9,4,4,4,4,5,10,10,4,8].forEach((parent,child)=>{kGraphCompound.nodesChildren.push({id:`n${child}`,shape:{width:15,height:15},meta:{parent:parent}}),kGraphCompound.nodesParents[parent].children.push(`n${child}`)}),[{s:1,t:0},{s:2,t:0},{s:3,t:0},{s:3,t:2},{s:4,t:0},{s:5,t:0},{s:6,t:0},{s:7,t:0},{s:8,t:0},{s:9,t:0},{s:11,t:10},{s:11,t:3},{s:11,t:2},{s:11,t:0},{s:12,t:11},{s:13,t:11},{s:14,t:11},{s:15,t:11},{s:17,t:16},{s:18,t:16},{s:18,t:17},{s:19,t:16},{s:19,t:17},{s:19,t:18},{s:20,t:16},{s:20,t:17},{s:20,t:18},{s:20,t:19},{s:21,t:16},{s:21,t:17},{s:21,t:18},{s:21,t:19},{s:21,t:20},{s:22,t:16},{s:22,t:17},{s:22,t:18},{s:22,t:19},{s:22,t:20},{s:22,t:21},{s:23,t:16},{s:23,t:17},{s:23,t:18},{s:23,t:19},{s:23,t:20},{s:23,t:21},{s:23,t:22},{s:23,t:12},{s:23,t:11},{s:24,t:23},{s:24,t:11},{s:25,t:24},{s:25,t:23},{s:25,t:11},{s:26,t:24},{s:26,t:11},{s:26,t:16},{s:26,t:25},{s:27,t:11},{s:27,t:23},{s:27,t:25},{s:27,t:24},{s:27,t:26},{s:28,t:11},{s:28,t:27},{s:29,t:23},{s:29,t:27},{s:29,t:11},{s:30,t:23},{s:31,t:30},{s:31,t:11},{s:31,t:23},{s:31,t:27},{s:32,t:11},{s:33,t:11},{s:33,t:27},{s:34,t:11},{s:34,t:29},{s:35,t:11},{s:35,t:34},{s:35,t:29},{s:36,t:34},{s:36,t:35},{s:36,t:11},{s:36,t:29},{s:37,t:34},{s:37,t:35},{s:37,t:36},{s:37,t:11},{s:37,t:29},{s:38,t:34},{s:38,t:35},{s:38,t:36},{s:38,t:37},{s:38,t:11},{s:38,t:29},{s:39,t:25},{s:40,t:25},{s:41,t:24},{s:41,t:25},{s:42,t:41},{s:42,t:25},{s:42,t:24},{s:43,t:11},{s:43,t:26},{s:43,t:27},{s:44,t:28},{s:44,t:11},{s:45,t:28},{s:47,t:46},{s:48,t:47},{s:48,t:25},{s:48,t:27},{s:48,t:11},{s:49,t:26},{s:49,t:11},{s:50,t:49},{s:50,t:24},{s:51,t:49},{s:51,t:26},{s:51,t:11},{s:52,t:51},{s:52,t:39},{s:53,t:51},{s:54,t:51},{s:54,t:49},{s:54,t:26},{s:55,t:51},{s:55,t:49},{s:55,t:39},{s:55,t:54},{s:55,t:26},{s:55,t:11},{s:55,t:16},{s:55,t:25},{s:55,t:41},{s:55,t:48},{s:56,t:49},{s:56,t:55},{s:57,t:55},{s:57,t:41},{s:57,t:48},{s:58,t:55},{s:58,t:48},{s:58,t:27},{s:58,t:57},{s:58,t:11},{s:59,t:58},{s:59,t:55},{s:59,t:48},{s:59,t:57},{s:60,t:48},{s:60,t:58},{s:60,t:59},{s:61,t:48},{s:61,t:58},{s:61,t:60},{s:61,t:59},{s:61,t:57},{s:61,t:55},{s:62,t:55},{s:62,t:58},{s:62,t:59},{s:62,t:48},{s:62,t:57},{s:62,t:41},{s:62,t:61},{s:62,t:60},{s:63,t:59},{s:63,t:48},{s:63,t:62},{s:63,t:57},{s:63,t:58},{s:63,t:61},{s:63,t:60},{s:63,t:55},{s:64,t:55},{s:64,t:62},{s:64,t:48},{s:64,t:63},{s:64,t:58},{s:64,t:61},{s:64,t:60},{s:64,t:59},{s:64,t:57},{s:64,t:11},{s:65,t:63},{s:65,t:64},{s:65,t:48},{s:65,t:62},{s:65,t:58},{s:65,t:61},{s:65,t:60},{s:65,t:59},{s:65,t:57},{s:65,t:55},{s:66,t:64},{s:66,t:58},{s:66,t:59},{s:66,t:62},{s:66,t:65},{s:66,t:48},{s:66,t:63},{s:66,t:61},{s:66,t:60},{s:67,t:57},{s:68,t:25},{s:68,t:11},{s:68,t:24},{s:68,t:27},{s:68,t:48},{s:68,t:41},{s:69,t:25},{s:69,t:68},{s:69,t:11},{s:69,t:24},{s:69,t:27},{s:69,t:48},{s:69,t:41},{s:70,t:25},{s:70,t:69},{s:70,t:68},{s:70,t:11},{s:70,t:24},{s:70,t:27},{s:70,t:41},{s:70,t:58},{s:71,t:27},{s:71,t:69},{s:71,t:68},{s:71,t:70},{s:71,t:11},{s:71,t:48},{s:71,t:41},{s:71,t:25},{s:72,t:26},{s:72,t:27},{s:72,t:11},{s:73,t:48},{s:74,t:48},{s:74,t:73},{s:75,t:69},{s:75,t:68},{s:75,t:25},{s:75,t:48},{s:75,t:41},{s:75,t:70},{s:75,t:71},{s:76,t:64},{s:76,t:65},{s:76,t:66},{s:76,t:63},{s:76,t:62},{s:76,t:48},{s:76,t:58}].forEach(({s:s,t:t})=>{kGraphCompound.edges.push({id:`e${s}->${t}`,source:{id:`n${s}`},target:{id:`n${t}`}})})}},[[335,1,2]]]);
//# sourceMappingURL=main.b0c76bd3090a90ea715c.bundle.js.map